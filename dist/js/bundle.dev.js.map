{"version":3,"sources":["dist/js/node_modules/browser-pack/_prelude.js","dist/js/dist/js/tmp/src/animation/animation-engine.ts","dist/js/dist/js/tmp/src/animation/animation-operation-events.ts","dist/js/dist/js/tmp/src/animation/animation-play-state.ts","dist/js/dist/js/tmp/src/carousel/carousel-base.ts","dist/js/dist/js/tmp/src/carousel/single-slide/single-slide-carousel.ts","dist/js/dist/js/tmp/src/collection/cancelable-collection-change-args.ts","dist/js/dist/js/tmp/src/collection/collection-change-args.ts","dist/js/dist/js/tmp/src/collection/collection-manager.ts","dist/js/dist/js/tmp/src/collection/html-children-manager.ts","dist/js/dist/js/tmp/src/collection/token-map.ts","dist/js/dist/js/tmp/src/main.ts","dist/js/dist/js/tmp/src/task/flow/task-flow-when.ts","dist/js/dist/js/tmp/src/task/flow/task-part-constraint.ts","dist/js/dist/js/tmp/src/task/operation/operation-manager.ts","dist/js/dist/js/tmp/src/task/task-engine.ts","dist/js/dist/js/tmp/src/task/task-part-when-events.ts","dist/js/dist/js/tmp/src/task/task-part-when-operator.ts","dist/js/node_modules/@babel/runtime/helpers/assertThisInitialized.js","dist/js/node_modules/@babel/runtime/helpers/classCallCheck.js","dist/js/node_modules/@babel/runtime/helpers/createClass.js","dist/js/node_modules/@babel/runtime/helpers/get.js","dist/js/node_modules/@babel/runtime/helpers/getPrototypeOf.js","dist/js/node_modules/@babel/runtime/helpers/inherits.js","dist/js/node_modules/@babel/runtime/helpers/interopRequireDefault.js","dist/js/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","dist/js/node_modules/@babel/runtime/helpers/setPrototypeOf.js","dist/js/node_modules/@babel/runtime/helpers/superPropBase.js","dist/js/node_modules/@babel/runtime/helpers/typeof.js","dist/js/node_modules/core-js/fn/promise.js","dist/js/node_modules/core-js/modules/_a-function.js","dist/js/node_modules/core-js/modules/_add-to-unscopables.js","dist/js/node_modules/core-js/modules/_an-instance.js","dist/js/node_modules/core-js/modules/_an-object.js","dist/js/node_modules/core-js/modules/_array-includes.js","dist/js/node_modules/core-js/modules/_classof.js","dist/js/node_modules/core-js/modules/_cof.js","dist/js/node_modules/core-js/modules/_core.js","dist/js/node_modules/core-js/modules/_ctx.js","dist/js/node_modules/core-js/modules/_defined.js","dist/js/node_modules/core-js/modules/_descriptors.js","dist/js/node_modules/core-js/modules/_dom-create.js","dist/js/node_modules/core-js/modules/_enum-bug-keys.js","dist/js/node_modules/core-js/modules/_export.js","dist/js/node_modules/core-js/modules/_fails.js","dist/js/node_modules/core-js/modules/_for-of.js","dist/js/node_modules/core-js/modules/_global.js","dist/js/node_modules/core-js/modules/_has.js","dist/js/node_modules/core-js/modules/_hide.js","dist/js/node_modules/core-js/modules/_html.js","dist/js/node_modules/core-js/modules/_ie8-dom-define.js","dist/js/node_modules/core-js/modules/_invoke.js","dist/js/node_modules/core-js/modules/_iobject.js","dist/js/node_modules/core-js/modules/_is-array-iter.js","dist/js/node_modules/core-js/modules/_is-object.js","dist/js/node_modules/core-js/modules/_iter-call.js","dist/js/node_modules/core-js/modules/_iter-create.js","dist/js/node_modules/core-js/modules/_iter-define.js","dist/js/node_modules/core-js/modules/_iter-detect.js","dist/js/node_modules/core-js/modules/_iter-step.js","dist/js/node_modules/core-js/modules/_iterators.js","dist/js/node_modules/core-js/modules/_library.js","dist/js/node_modules/core-js/modules/_microtask.js","dist/js/node_modules/core-js/modules/_new-promise-capability.js","dist/js/node_modules/core-js/modules/_object-create.js","dist/js/node_modules/core-js/modules/_object-dp.js","dist/js/node_modules/core-js/modules/_object-dps.js","dist/js/node_modules/core-js/modules/_object-gpo.js","dist/js/node_modules/core-js/modules/_object-keys-internal.js","dist/js/node_modules/core-js/modules/_object-keys.js","dist/js/node_modules/core-js/modules/_perform.js","dist/js/node_modules/core-js/modules/_promise-resolve.js","dist/js/node_modules/core-js/modules/_property-desc.js","dist/js/node_modules/core-js/modules/_redefine-all.js","dist/js/node_modules/core-js/modules/_redefine.js","dist/js/node_modules/core-js/modules/_set-species.js","dist/js/node_modules/core-js/modules/_set-to-string-tag.js","dist/js/node_modules/core-js/modules/_shared-key.js","dist/js/node_modules/core-js/modules/_shared.js","dist/js/node_modules/core-js/modules/_species-constructor.js","dist/js/node_modules/core-js/modules/_string-at.js","dist/js/node_modules/core-js/modules/_task.js","dist/js/node_modules/core-js/modules/_to-absolute-index.js","dist/js/node_modules/core-js/modules/_to-integer.js","dist/js/node_modules/core-js/modules/_to-iobject.js","dist/js/node_modules/core-js/modules/_to-length.js","dist/js/node_modules/core-js/modules/_to-object.js","dist/js/node_modules/core-js/modules/_to-primitive.js","dist/js/node_modules/core-js/modules/_uid.js","dist/js/node_modules/core-js/modules/_user-agent.js","dist/js/node_modules/core-js/modules/_wks.js","dist/js/node_modules/core-js/modules/core.get-iterator-method.js","dist/js/node_modules/core-js/modules/es6.array.iterator.js","dist/js/node_modules/core-js/modules/es6.object.to-string.js","dist/js/node_modules/core-js/modules/es6.promise.js","dist/js/node_modules/core-js/modules/es6.string.iterator.js","dist/js/node_modules/core-js/modules/es7.promise.finally.js","dist/js/node_modules/core-js/modules/es7.promise.try.js","dist/js/node_modules/core-js/modules/web.dom.iterable.js","dist/js/node_modules/events/events.js"],"names":[],"mappings":"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J,CAAkB,UAAS,OAAT,EAAkB,MAAlB,EAAwB;AAC7C,QAAA,UAAU,CAAC,YAAA;AACP,cAAI,UAAU,CAAC,KAAX,IAAoB,IAAxB,EAA8B;AAC1B,YAAA,OAAO;AACV,WAFD,MAEO;AACH,YAAA,IAAI,CAAC,kBAAL,CAAwB,UAAU,CAAC,KAAnC,EACK,IADL,CACU,OADV;AAEH;AACJ,SAPS,EAOP,UAAU,CAAC,MAPJ,CAAV;AAQH,OATM,CAAP;AAUH;;;;;;;;;;;;;;ACxTE,IAAM,qBAAqB,GAAG;AAIjC,EAAA,GAAG,EAAE,UAJ4B;AAQjC,EAAA,KAAK,EAAE;AAR0B,CAA9B;;;;;;;;;;ACAP,IAAY,oBAAZ;;;AAAA,CAAA,UAAY,oBAAZ,EAAgC;AAI5B,EAAA,oBAAA,CAAA,oBAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAA;AAIA,EAAA,oBAAA,CAAA,oBAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,IAAA;AACH,CATD,EAAY,oBAAoB,oCAApB,oBAAoB,GAAA,EAAA,CAAhC;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;;ACFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.dev.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import { CAROUSEL_STYLES } from '../carousel/carousel-base';\r\nimport { OperationManager } from '../task/operation/operation-manager';\r\nimport { TaskEngine } from '../task/task-engine';\r\nimport { IAnimationCancelEventArgs } from './animation-cancel-event-args';\r\nimport { IAnimationFlowPart } from './animation-flow-part';\r\nimport { ANIMATION_OPERATION_EVENTS } from './animation-operation-events';\r\nimport { AnimationPlayStateValue } from './animation-play-state';\r\nimport { IAnimationStateChangeEventArgs } from './animation-state-change-event-args';\r\n\r\n/**\r\n * Represents a single animation engine.\r\n */\r\nexport class SingleAnimationEngine extends TaskEngine<IAnimationFlowPart> {\r\n\r\n    //#region Attributes\r\n\r\n    //#region Operators\r\n\r\n    /**\r\n     * Animation cancel operation manager.\r\n     */\r\n    protected animationCancelManager: OperationManager<IAnimationCancelEventArgs>;\r\n\r\n    /**\r\n     * Animation state change operation manager.\r\n     */\r\n    protected animationStateChangeManager: OperationManager<IAnimationStateChangeEventArgs>;\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     */\r\n    public constructor() {\r\n        super();\r\n\r\n        this.animationCancelManager =\r\n            new OperationManager<IAnimationCancelEventArgs>(\r\n                ANIMATION_OPERATION_EVENTS.ANIMATION_CANCEL,\r\n                this.eventEmitter,\r\n            );\r\n        this.animationStateChangeManager =\r\n            new OperationManager<IAnimationStateChangeEventArgs>(\r\n                ANIMATION_OPERATION_EVENTS.ANIMATION_STATE_CHANGE,\r\n                this.eventEmitter,\r\n            );\r\n    }\r\n\r\n    //#region Public\r\n\r\n    /**\r\n     * Disposes the instance.\r\n     */\r\n    public dispose() {\r\n        this.animationCancelManager.dispose();\r\n        this.animationStateChangeManager.dispose();\r\n    }\r\n\r\n    //#region Operations\r\n\r\n    /**\r\n     * Cancels the animation.\r\n     * @param aliases Aliases of the parts to cancel or null to cancel all the parts.\r\n     */\r\n    public cancelAnimation(aliases: string[]): void {\r\n        this.eventEmitter.emit(\r\n            ANIMATION_OPERATION_EVENTS.ANIMATION_CANCEL,\r\n            { aliases : aliases } as IAnimationCancelEventArgs,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Pauses the engine animation.\r\n     * @param aliases Aliases of the animation parts to pause or null to pause all the parts.\r\n     */\r\n    public pause(aliases: string[]): void {\r\n        this.eventEmitter.emit(\r\n            ANIMATION_OPERATION_EVENTS.ANIMATION_STATE_CHANGE,\r\n            {\r\n                aliases: aliases,\r\n                value: AnimationPlayStateValue.paused,\r\n            } as IAnimationStateChangeEventArgs,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Resumes the engine animation.\r\n     * @param aliases Aliases of the animation parts to resume or null to resume all the parts.\r\n     */\r\n    public resume(aliases: string[]): void {\r\n        this.eventEmitter.emit(\r\n            ANIMATION_OPERATION_EVENTS.ANIMATION_STATE_CHANGE,\r\n            {\r\n                aliases: aliases,\r\n                value: AnimationPlayStateValue.running,\r\n            } as IAnimationStateChangeEventArgs,\r\n        );\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Handles an animation part.\r\n     *\r\n     * @param animationFlow Animation flow that contains the anmation part to handle.\r\n     * @param part Animation part to handle.\r\n     * @param eventEmitter Event emitter for the animation.\r\n     *\r\n     * @returns Promise resolved once the animation of the part is finished.\r\n     */\r\n    protected handleTaskPart(part: IAnimationFlowPart): Promise<void> {\r\n        const that = this;\r\n        part.pendingOperations = {\r\n            cancel: {\r\n                isPending: false,\r\n                operationToken: this.animationCancelManager.subscribe(\r\n                    part.alias,\r\n                    function(eventArgs: IAnimationCancelEventArgs) {\r\n                        part.pendingOperations.cancel.isPending = true;\r\n                        that.animationCancelManager.unsubscribe(\r\n                            part.alias, part.pendingOperations.cancel.operationToken,\r\n                        );\r\n                    },\r\n                ),\r\n            },\r\n            pause: {\r\n                isPending: false,\r\n                operationToken: this.animationStateChangeManager.subscribe(\r\n                    part.alias,\r\n                    function(eventArgs: IAnimationStateChangeEventArgs) {\r\n                        part.pendingOperations.pause.isPending =\r\n                            eventArgs.value === AnimationPlayStateValue.paused;\r\n                    },\r\n                ),\r\n            },\r\n        };\r\n\r\n        return super.handleTaskPart(part);\r\n    }\r\n\r\n    /**\r\n     * Performs a task part.\r\n     * @param part Task part to be performed.\r\n     * @returns Promise resolved once the part task is performed.\r\n     */\r\n    protected performTask(part: IAnimationFlowPart): PromiseLike<{} | void> {\r\n\r\n        if (part.pendingOperations) {\r\n            this.animationCancelManager.unsubscribe(part.alias, part.pendingOperations.cancel.operationToken);\r\n            this.animationStateChangeManager.unsubscribe(part.alias, part.pendingOperations.pause.operationToken);\r\n        }\r\n\r\n        const promises: Array<Promise<void>> = new Array(part.elements.length);\r\n\r\n        // 2. Perform the animation.\r\n        for (var i = 0; i < part.elements.length; ++i) {\r\n            promises[i] = this.handleAnimationOverElement(part.elements[i], part);\r\n        }\r\n\r\n        if (part.pendingOperations) {\r\n            if (part.pendingOperations.pause.isPending) {\r\n                this.pause([part.alias]);\r\n                part.pendingOperations.pause.isPending = false;\r\n            }\r\n\r\n            if (part.pendingOperations.cancel.isPending) {\r\n                this.cancelAnimation([part.alias]);\r\n                part.pendingOperations.cancel.isPending = false;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    //#region Element animation\r\n\r\n    /**\r\n     * Handles the animation over an element.\r\n     *\r\n     * @param element element to be animated.\r\n     * @param part Part that contains the element to be animated.\r\n     *\r\n     * @returns Promise resolved once the animation over the element is finished.\r\n     */\r\n    protected handleAnimationOverElement(element: HTMLElement, part: IAnimationFlowPart): Promise<void> {\r\n        const styles: string[] = part.styles;\r\n\r\n        if (styles) {\r\n            if (styles.length < 1) {\r\n                throw new Error('It\\'s required to have at least one class to generate an animation.');\r\n            }\r\n        } else {\r\n            throw new Error('It\\'s required to have an array of styles to generate an animation.');\r\n        }\r\n\r\n        const that = this;\r\n\r\n        return new Promise<void>(function(resolve, reject) {\r\n            try {\r\n                const animationFunctions: Array<((event: TransitionEvent) => void)> = new Array();\r\n                var currentAnimationIndex: number = null;\r\n\r\n                const onAnimationCancel = function(args: IAnimationCancelEventArgs) {\r\n                    // Resume the animation if it is paused.\r\n                    onAnimationPlayStateChange({aliases: args.aliases, value: AnimationPlayStateValue.running});\r\n\r\n                    element.classList.add(CAROUSEL_STYLES.CLEAR_ANIMATION);\r\n\r\n                    if (null != currentAnimationIndex) {\r\n                        element.classList.remove(styles[currentAnimationIndex]);\r\n                    }\r\n\r\n                    that.unregisterAnimationListener(element, animationFunctions[currentAnimationIndex]);\r\n                    element.classList.remove(CAROUSEL_STYLES.CLEAR_ANIMATION);\r\n\r\n                    that.animationCancelManager.unsubscribe(part.alias, cancelToken);\r\n                    that.animationStateChangeManager.unsubscribe(part.alias, playStateChangetoken);\r\n\r\n                    resolve();\r\n                };\r\n\r\n                const cancelToken = that.animationCancelManager.subscribe(part.alias, onAnimationCancel);\r\n\r\n                const onAnimationPlayStateChange = function(args: IAnimationStateChangeEventArgs) {\r\n                    if (AnimationPlayStateValue.paused === args.value) {\r\n                        if (!element.classList.contains(CAROUSEL_STYLES.ANIMATION_PAUSED)) {\r\n                            element.classList.add(CAROUSEL_STYLES.ANIMATION_PAUSED);\r\n                        }\r\n                    } else if (AnimationPlayStateValue.running === args.value) {\r\n                        if (element.classList.contains(CAROUSEL_STYLES.ANIMATION_PAUSED)) {\r\n                            element.classList.remove(CAROUSEL_STYLES.ANIMATION_PAUSED);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                const playStateChangetoken =\r\n                    that.animationStateChangeManager.subscribe(part.alias, onAnimationPlayStateChange);\r\n\r\n                for (var i = 1; i < styles.length; ++i) {\r\n                    animationFunctions.push(function(index) {\r\n                        return function(event: TransitionEvent) {\r\n                            element.classList.remove(styles[index - 1]);\r\n                            that.unregisterAnimationListener(element, animationFunctions[index - 1]);\r\n                            that.registerAnimationListener(element, animationFunctions[index]);\r\n                            element.classList.add(styles[index]);\r\n                            currentAnimationIndex = index;\r\n                        };\r\n                    } (i));\r\n                }\r\n\r\n                // Add the clear function\r\n                animationFunctions.push(function(event: TransitionEvent) {\r\n                    element.classList.add(CAROUSEL_STYLES.CLEAR_ANIMATION);\r\n                    element.classList.remove(styles[styles.length - 1]);\r\n                    element.classList.remove(CAROUSEL_STYLES.CLEAR_ANIMATION);\r\n                    that.unregisterAnimationListener(element, animationFunctions[animationFunctions.length - 1]);\r\n                    currentAnimationIndex = null;\r\n                    that.animationCancelManager.unsubscribe(part.alias, cancelToken);\r\n                    that.animationStateChangeManager.unsubscribe(part.alias, playStateChangetoken);\r\n                    resolve();\r\n                });\r\n\r\n                that.registerAnimationListener(element, animationFunctions[0]);\r\n                element.classList.add(styles[0]);\r\n                currentAnimationIndex = 0;\r\n            } catch (ex) {\r\n                reject(ex);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the end of a transition over an element.\r\n     * @param element Element whose event will be handled.\r\n     * @param listener Event listener.\r\n     */\r\n    private registerAnimationListener(element: HTMLElement, listener: (element: TransitionEvent) => void): void {\r\n        element.addEventListener('animationend', listener);\r\n        element.addEventListener('webkitAnimationEnd', listener);\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes an event handler from the list of listeners of an element\r\n     * @param element Target element.\r\n     * @param listener Listener to be unsubscribed.\r\n     */\r\n    private unregisterAnimationListener(element: HTMLElement, listener: (element: TransitionEvent) => void): void {\r\n        element.removeEventListener('animationend', listener);\r\n        element.removeEventListener('webkitAnimationEnd', listener);\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","export const ANIMATION_OPERATION_EVENTS = {\r\n    /**\r\n     * Forces the cancelation of the current animation.\r\n     */\r\n    ANIMATION_CANCEL: 'anim.cancel',\r\n    /**\r\n     * Changes the animation play state of the elements of the animation.\r\n     */\r\n    ANIMATION_STATE_CHANGE: 'anim.state.change',\r\n};\r\n","/**\r\n * Represents the play state of an animation\r\n */\r\nexport enum AnimationPlayStateValue {\r\n    /**\r\n     * Value to represent a paused status.\r\n     */\r\n    paused,\r\n    /**\r\n     * Value to represent a running status.\r\n     */\r\n    running,\r\n}\r\n","/**\n * Carousel classes used for multiple purposes.\n */\nexport const CAROUSEL_STYLES = {\n    ANIMATION_PAUSED: 'sora-animation-paused',\n    CAROUSEL: 'sora-carousel',\n    CLEAR_ANIMATION: 'sora-clear-animations',\n    SLIDE: 'sora-slide',\n    WRAPPER: 'sora-wrapper',\n};\n\n/**\n * Represents a generic carousel.\n *\n * 1. Any carousel has elements.\n * 2. Any carousel has a topology.\n * 3. Any carousel has transitions.\n */\nexport abstract class CarouselBase {\n    /**\n     * Carousel handler.\n     * 3. Any carousel has transitions.\n     * @param action action to be handled\n     * @param options options for the action.\n     */\n    public abstract handle(action: string, options: {[key: string]: any}): void;\n}\n","import { EventEmitter } from 'events';\nimport { SingleAnimationEngine } from '../../animation/animation-engine';\nimport { IAnimationFlowPart } from '../../animation/animation-flow-part';\nimport { AnimationPlayStateValue } from '../../animation/animation-play-state';\nimport { CancelableCollectionChangeEventArgs } from '../../collection/cancelable-collection-change-args';\nimport { CollectionChangeEventArgs } from '../../collection/collection-change-args';\nimport { COLLECTION_MANAGER_EVENTS } from '../../collection/collection-manager';\nimport { HtmlChildrenManager } from '../../collection/html-children-manager';\nimport { ITaskFlow } from '../../task/flow/task-flow';\nimport {\n    CAROUSEL_STYLES,\n    CarouselBase,\n} from '../carousel-base';\nimport {\n    ISingleSlideCarouselAnimationEndEventArgs,\n    ISingleSlideCarouselAnimationPlayStateChangeEventArgs,\n    ISingleSlideCarouselAnimationStartEventArgs,\n    ISingleSlideCarouselCancelAnimationEventArgs,\n} from './animation-events';\nimport { ICarouselAnimationChildrenStyles } from './carousel-animation';\nimport { ISingleSlideCarouselCreateWaitPromiseOptions } from './create-wait-promise-options';\nimport { ISingleSlideCarouselCreationOptions } from './creation-options';\nimport { ISingleSlideCarouselGoToAnimationStatus } from './go-to-animation-status';\nimport { ISingleSlideCarouselGotoOptions } from './go-to-options';\n\n/* #region Constants */\n\n/**\n * Actions avaiable for the SingleSlideCarousel.\n */\nexport const SINGLE_SLIDE_CAROUSEL_ACTIONS = {\n    GO_TO: 'to',\n    GO_TO_NEXT: 'next',\n    GO_TO_PREVIOUS: 'prev',\n};\n\n/**\n * Events directly handled by the carousel.\n */\nexport const SINGLE_SLIDE_CAROUSEL_EVENTS = {\n    ON_ANIMATION_END: 'car.anim.out',\n    ON_ANIMATION_PLAY_STATE_CHANGE: 'car.anim.state.ch',\n    ON_ANIMATION_START: 'car.anim.in',\n    ON_CANCEL_ANIMATION: 'car.anim.cancel',\n};\n\nexport const SINGLE_SLIDE_CAROUSEL_PARTS_ALIASES = {\n    ENTER: 'enter-part',\n    LEAVE: 'leave-part',\n};\n\n/**\n * Carousel classes used for multiple purposes.\n */\nexport const SINGLE_SLIDE_CAROUSEL_STYLES = {\n    /**\n     * Style to apply to hidden slides.\n     */\n    SLIDE_HIDDEN: 'sora-hidden',\n    /**\n     * Style to apply to achieve position: relative.\n     */\n    SORA_RELATIVE: 'sora-relative',\n};\n\n/* #endregion */\n\n/**\n * Represents a carousel with a single active slide at a time.\n */\nexport class SingleSlideCarousel extends CarouselBase {\n\n    //#region Attributes\n\n    /**\n     * Active index of the elements of the carousel.\n     */\n    protected activeIndex: number;\n\n    /**\n     * Current active animation\n     */\n    protected currentAnimation: ISingleSlideCarouselGotoOptions;\n\n    /**\n     * collection manager\n     */\n    protected elementsManager: HtmlChildrenManager;\n\n    /**\n     * Engine animation.\n     */\n    protected engineAnimation: SingleAnimationEngine;\n\n    /**\n     * Flag to determine if the carousel animation is paused.\n     */\n    protected paused: boolean;\n\n    //#endregion\n\n    //#region Events\n\n    /**\n     * Event emitter for this instance\n     */\n    protected eventEmitter: EventEmitter;\n\n    //#endregion\n\n    /**\n     * Creates a new instance of this class.\n     * @param element DOM element associated to the carousel.\n     */\n    public constructor(element: HTMLElement, options: ISingleSlideCarouselCreationOptions) {\n        super();\n\n        if (element == null) {\n            throw new Error('The element must not be null.');\n        }\n        if (!element.classList.contains(CAROUSEL_STYLES.CAROUSEL)) {\n            throw new Error('The carousel element must contain the class \"' + CAROUSEL_STYLES.CAROUSEL + '\".');\n        }\n\n        const soraWrapper = element.querySelector('.' + CAROUSEL_STYLES.WRAPPER);\n\n        if (soraWrapper == null) {\n            throw new Error('The element has no child with class \\'sora-wrapper\\'.');\n        }\n\n        const children: HTMLElement[] = new Array();\n\n        for (var i = 0; i < soraWrapper.children.length; ++i) {\n            if (soraWrapper.children[i].classList.contains(CAROUSEL_STYLES.SLIDE)) {\n                children.push(soraWrapper.children[i] as HTMLElement);\n            }\n        }\n\n        this.activeIndex = options.index || 0;\n        this.currentAnimation = null;\n        this.eventEmitter = new EventEmitter();\n        this.elementsManager = new HtmlChildrenManager(children, this.eventEmitter, soraWrapper as HTMLElement);\n\n        if (this.activeIndex < 0 || this.activeIndex >= this.elementsManager.getLength()) {\n            throw new Error('Invalid options.index. There is no element with index ' + options.index + '.');\n        }\n\n        for (var i = 0; i < children.length; ++i) {\n            if (i === this.activeIndex) {\n                children[i].classList.add(SINGLE_SLIDE_CAROUSEL_STYLES.SORA_RELATIVE);\n            } else {\n                children[i].classList.add(SINGLE_SLIDE_CAROUSEL_STYLES.SLIDE_HIDDEN);\n            }\n        }\n\n        const that = this;\n\n        // Add listeners\n        const onBeforeChange = function(eventArgs: CancelableCollectionChangeEventArgs<HTMLElement>) {\n            const indexMap = eventArgs.getIndexMap();\n            if (null == indexMap[that.activeIndex]) {\n                eventArgs.setPreventDefault();\n            }\n        };\n\n        const onAfterChange = function(eventArgs: CollectionChangeEventArgs<HTMLElement>) {\n            if (!eventArgs.getPreventDefault()) {\n                const indexMap = eventArgs.getIndexMap();\n                that.activeIndex = indexMap[that.activeIndex];\n            }\n        };\n\n        this.addListener(COLLECTION_MANAGER_EVENTS.collectionBeforeChange, onBeforeChange);\n        this.addListener(COLLECTION_MANAGER_EVENTS.collectionAfterChange, onAfterChange);\n\n        this.engineAnimation = new SingleAnimationEngine();\n    }\n\n    //#region Public\n\n    /**\n     * Subscribes a listener to an event of the carousel.\n     * @param event Event to listen.\n     * @param listener Listener to subscribe.\n     */\n    public addListener(event: string | symbol, listener: (... args: any[]) => void): void {\n        this.eventEmitter.addListener(event, listener);\n    }\n\n    /**\n     * Creates a promise that waits for a time. The amount of time\n     * @param options ISingleSlideCarouselCreateWaitPromiseOptions.\n     */\n    public createWaitPromise(options: ISingleSlideCarouselCreateWaitPromiseOptions): Promise<void> {\n        const that = this;\n        return new Promise<void>(function(resolve, reject) {\n            var lastTimeRun: number;\n            var timeToWait = options.millis;\n\n            if (that.paused) {\n                lastTimeRun = null;\n            } else {\n                var waitInterval = setInterval(function() {\n                    removeListeners();\n                    resolve();\n                }, timeToWait);\n                lastTimeRun = new Date().getTime();\n            }\n\n            var onCancelAnimation: () => void = null;\n\n            if (options.stopOnCancelAnimation) {\n                onCancelAnimation = function() {\n                    removeListeners();\n                    resolve();\n                };\n                that.addListener(SINGLE_SLIDE_CAROUSEL_EVENTS.ON_CANCEL_ANIMATION, onCancelAnimation);\n            }\n\n            const onPlayStateChange = function(args: ISingleSlideCarouselAnimationPlayStateChangeEventArgs) {\n                if (AnimationPlayStateValue.paused === args.value) {\n                    // Pause\n                    timeToWait = timeToWait - (new Date().getTime() - lastTimeRun);\n                    clearInterval(waitInterval);\n                } else if (AnimationPlayStateValue.running === args.value) {\n                    // Resume\n                    lastTimeRun = new Date().getTime();\n\n                    if (0 < timeToWait) {\n                        waitInterval = setInterval(function() {\n                            that.removeListener(\n                                SINGLE_SLIDE_CAROUSEL_EVENTS.ON_ANIMATION_PLAY_STATE_CHANGE,\n                                onPlayStateChange,\n                            );\n                            if (null != onCancelAnimation) {\n                                that.removeListener(\n                                    SINGLE_SLIDE_CAROUSEL_EVENTS.ON_CANCEL_ANIMATION,\n                                    onCancelAnimation,\n                                );\n                            }\n                            resolve();\n                        }, timeToWait);\n                    } else {\n                        removeListeners();\n                        resolve();\n                    }\n                }\n            };\n\n            const removeListeners = function() {\n                that.removeListener(SINGLE_SLIDE_CAROUSEL_EVENTS.ON_ANIMATION_PLAY_STATE_CHANGE, onPlayStateChange);\n                if (null != onCancelAnimation) {\n                    that.removeListener(\n                        SINGLE_SLIDE_CAROUSEL_EVENTS.ON_CANCEL_ANIMATION,\n                        onCancelAnimation,\n                    );\n                }\n            };\n\n            that.addListener(SINGLE_SLIDE_CAROUSEL_EVENTS.ON_ANIMATION_PLAY_STATE_CHANGE, onPlayStateChange);\n        });\n    }\n\n    /**\n     * Forces the carousel to change its active slide. Any animation will be canceled in the process.\n     * @param activeIndex Index of the new active slide of the carousel.\n     */\n    public forceActiveSlide(activeIndex: number) {\n        const eventArgs: ISingleSlideCarouselCancelAnimationEventArgs = { activeIndex: activeIndex };\n\n        this.engineAnimation.cancelAnimation(null);\n        // The call over cancelAnimation will resume any paused animation.\n        this.paused = false;\n        this.activeIndex = activeIndex;\n        this.resetCarouselStructure(activeIndex);\n\n        this.eventEmitter.emit(SINGLE_SLIDE_CAROUSEL_EVENTS.ON_CANCEL_ANIMATION, eventArgs);\n    }\n\n    /**\n     * Obtains the active slide of the carousel\n     */\n    public getActiveElement(): HTMLElement {\n        return this.elementsManager.getCollection()[this.activeIndex];\n    }\n\n    /**\n     * Obtains the active index in the elements array of the carousel\n     */\n    public getActiveIndex(): number {\n        return this.activeIndex;\n    }\n\n    /**\n     * Returns the collection manager of the instance.\n     * @returns Collection manager of the slide elements.\n     */\n    public getElementsManager(): HtmlChildrenManager {\n        return this.elementsManager;\n    }\n\n    /**\n     * Determines if the carousel has an active animation, even if the animation is Paused.\n     * @returns True if the carousel has an active animation.\n     */\n    public hasActiveAnimation(): boolean {\n        return null != this.currentAnimation;\n    }\n\n    public handle(action: string, options: {[key: string]: any}): ISingleSlideCarouselGoToAnimationStatus {\n        switch (action) {\n            case SINGLE_SLIDE_CAROUSEL_ACTIONS.GO_TO:\n                if (options == null || typeof options.index !== 'number') {\n                    throw new Error('Invalid options for \\'' + SINGLE_SLIDE_CAROUSEL_ACTIONS.GO_TO + '\\'.');\n                }\n                return this.handleGoTo(options as ISingleSlideCarouselGotoOptions);\n            case SINGLE_SLIDE_CAROUSEL_ACTIONS.GO_TO_NEXT:\n                options.index = (this.activeIndex + 1) % this.elementsManager.getLength();\n                return this.handle(SINGLE_SLIDE_CAROUSEL_ACTIONS.GO_TO, options);\n            case SINGLE_SLIDE_CAROUSEL_ACTIONS.GO_TO_PREVIOUS:\n                const elementsLength = this.elementsManager.getLength();\n                options.index = ((this.activeIndex - 1) % elementsLength + elementsLength) % elementsLength;\n                return this.handle(SINGLE_SLIDE_CAROUSEL_ACTIONS.GO_TO, options);\n        }\n    }\n\n    /**\n     * Returns true if the carousel animation is paused.\n     * @returns True if the carousel is paused and false in any other case.\n     */\n    public isPaused() {\n        return this.paused;\n    }\n\n    /**\n     * Pauses the animations currently handled by the carousel.\n     */\n    public pause(): void {\n        if (!this.paused) {\n            this.engineAnimation.pause(null);\n            this.paused = true;\n            this.eventEmitter.emit(\n                SINGLE_SLIDE_CAROUSEL_EVENTS.ON_ANIMATION_PLAY_STATE_CHANGE,\n                { value : AnimationPlayStateValue.paused } as ISingleSlideCarouselAnimationPlayStateChangeEventArgs,\n            );\n        }\n    }\n\n    /**\n     * Unsubscribes a listener to an event of the carousel.\n     * @param event Event associated.\n     * @param listener Listener to unsubscribe.\n     */\n    public removeListener(event: string | symbol, listener: (... args: any[]) => void): void {\n        this.eventEmitter.removeListener(event, listener);\n    }\n\n    /**\n     * Resumes the animations currently handled by the carousel.\n     */\n    public resume(): void {\n        if (this.paused) {\n            this.engineAnimation.resume(null);\n            this.paused = false;\n            this.eventEmitter.emit(\n                SINGLE_SLIDE_CAROUSEL_EVENTS.ON_ANIMATION_PLAY_STATE_CHANGE,\n                { value: AnimationPlayStateValue.running } as ISingleSlideCarouselAnimationPlayStateChangeEventArgs,\n            );\n        }\n    }\n\n    //#endregion\n\n    //#region Protected\n\n    /**\n     * Creates an animation flow based on animation options.\n     *\n     * @param enterElement Element to apply the enter animation.\n     * @param leaveElement Element to apply the leave animation.\n     * @param options Animation options.\n     *\n     * @returns Animation flow from the animation options.\n     */\n    protected generateGoToAnimationFlow(\n        enterElement: HTMLElement,\n        leaveElement: HTMLElement,\n        options: ISingleSlideCarouselGotoOptions,\n    ): ITaskFlow<IAnimationFlowPart> {\n        const innerParts: IAnimationFlowPart[] = [\n            {\n                alias: SINGLE_SLIDE_CAROUSEL_PARTS_ALIASES.ENTER,\n                elements: [ enterElement ],\n                styles: options.enterAnimation.slideStyles,\n                when: null,\n            },\n            {\n                alias: SINGLE_SLIDE_CAROUSEL_PARTS_ALIASES.LEAVE,\n                elements: [ leaveElement ],\n                styles: options.leaveAnimation.slideStyles,\n                when: null,\n            },\n        ];\n\n        const generateChildrenParts = function(\n            parentElement: HTMLElement,\n            childrenStyles: ICarouselAnimationChildrenStyles[],\n            aliasBase: string,\n        ) {\n            if (childrenStyles) {\n                for (var i = 0; i < childrenStyles.length; ++i) {\n                    innerParts.push({\n                        alias: aliasBase + i.toString(),\n                        elements: function(): HTMLElement[] {\n                            const elements: HTMLElement[] = new Array();\n                            const animationObject: ICarouselAnimationChildrenStyles = childrenStyles[i];\n                            const childrenElements = parentElement.querySelectorAll(animationObject.selector);\n\n                            for (const childrenElement of childrenElements) {\n                                elements.push(childrenElement as HTMLElement);\n                            }\n\n                            return elements;\n                        } (),\n                        styles: childrenStyles[i].styles,\n                        when: null,\n                    });\n                }\n            }\n        };\n\n        generateChildrenParts(\n            enterElement,\n            options.enterAnimation.childrenStyles,\n            SINGLE_SLIDE_CAROUSEL_PARTS_ALIASES.ENTER,\n        );\n        generateChildrenParts(\n            leaveElement,\n            options.leaveAnimation.childrenStyles,\n            SINGLE_SLIDE_CAROUSEL_PARTS_ALIASES.LEAVE,\n        );\n\n        const innerPartsMap: { [key: string]: IAnimationFlowPart } = { };\n\n        for (const innerPart of innerParts) {\n            innerPartsMap[innerPart.alias] = innerPart;\n        }\n        const animationFlow: ITaskFlow<IAnimationFlowPart> = {\n            parts: innerParts,\n        };\n\n        return animationFlow;\n    }\n\n    /**\n     * Resets the carousel structure. Sets a new active element for the carousel.\n     * @param activeIndex Current active index.\n     */\n    protected resetCarouselStructure(activeIndex: number) {\n        // This operation is atomic in a single-thread environment, so we can store the collection.\n        const collection = this.elementsManager.getCollection();\n        for (var i = 0; i < collection.length; ++i) {\n            while (collection[i].classList.length > 0) {\n                collection[i].classList.remove(collection[i].classList.item(0));\n            }\n\n            collection[i].classList.add(CAROUSEL_STYLES.SLIDE);\n\n            if (i === activeIndex) {\n                collection[i].classList.add(SINGLE_SLIDE_CAROUSEL_STYLES.SORA_RELATIVE);\n            } else {\n                collection[i].classList.add(SINGLE_SLIDE_CAROUSEL_STYLES.SLIDE_HIDDEN);\n            }\n        }\n    }\n\n    //#endregion\n\n    //#region Private\n\n    /**\n     * Handles the GoTo operation.\n     * @param options Options with the index and the custom animation to display.\n     */\n    private handleGoTo(options: ISingleSlideCarouselGotoOptions): ISingleSlideCarouselGoToAnimationStatus {\n        if (options.index < 0 || options.index >= this.elementsManager.getLength()) {\n            throw new Error('Invalid index. There is no element with index ' + options.index + '.');\n        }\n\n        if (options.index === this.activeIndex) {\n            throw new Error('Invalid index. It\\'s not allowed to go to the current active slide');\n        }\n        if (null == this.currentAnimation) {\n            this.currentAnimation = options;\n        } else {\n            throw new Error(\n                'It\\'s not allowed to start an animation while an existing animation over an slide element is active',\n            );\n        }\n\n        const oldActiveElement = this.elementsManager.getCollection()[this.activeIndex];\n        var newActiveIndex: number = options.index;\n\n        this.eventEmitter.emit(SINGLE_SLIDE_CAROUSEL_EVENTS.ON_ANIMATION_START, {\n            options: options,\n        } as ISingleSlideCarouselAnimationStartEventArgs);\n\n        const that = this;\n\n        const onBeforeChange = function(eventArgs: CancelableCollectionChangeEventArgs<HTMLElement>) {\n            const indexMap = eventArgs.getIndexMap();\n            if (null == indexMap[newActiveIndex]) {\n                eventArgs.setPreventDefault();\n            }\n        };\n\n        const onAfterChange = function(eventArgs: CollectionChangeEventArgs<HTMLElement>) {\n            if (!eventArgs.getPreventDefault()) {\n                const indexMap = eventArgs.getIndexMap();\n                newActiveIndex = indexMap[newActiveIndex];\n            }\n        };\n\n        this.addListener(COLLECTION_MANAGER_EVENTS.collectionBeforeChange, onBeforeChange);\n        this.addListener(COLLECTION_MANAGER_EVENTS.collectionAfterChange, onAfterChange);\n\n        const newActiveElement = this.elementsManager.getCollection()[newActiveIndex];\n\n        newActiveElement.classList.remove(SINGLE_SLIDE_CAROUSEL_STYLES.SLIDE_HIDDEN);\n\n        var animationCanceled = false;\n\n        const cancelAnimationHandler = function() {\n            animationCanceled = true;\n            that.currentAnimation = null;\n        };\n\n        const animationFlow = this.generateGoToAnimationFlow(newActiveElement, oldActiveElement, options);\n        const animationPromises: Array<Promise<void>> = this.engineAnimation.handle(animationFlow);\n        const ANIMATION_ENTER_INDEX: number = 0;\n        const ANIMATION_LEAVE_INDEX: number = 1;\n\n        const hideLeaveSlideAfterAnimationEnds = new Promise<void>(function(resolve, reject) {\n            animationPromises[ANIMATION_LEAVE_INDEX].then(function(animationOptions) {\n                if (!animationCanceled) {\n                    oldActiveElement.classList.add(SINGLE_SLIDE_CAROUSEL_STYLES.SLIDE_HIDDEN);\n                    oldActiveElement.classList.remove(SINGLE_SLIDE_CAROUSEL_STYLES.SORA_RELATIVE);\n                    newActiveElement.classList.add(SINGLE_SLIDE_CAROUSEL_STYLES.SORA_RELATIVE);\n                }\n                resolve();\n            }).catch(function(err) {\n                reject(err);\n            });\n        });\n\n        this.addListener(SINGLE_SLIDE_CAROUSEL_EVENTS.ON_CANCEL_ANIMATION, cancelAnimationHandler);\n\n        const soraHandlerStatus: Promise<void> = new Promise<void>(function(resolve, reject) {\n            Promise.all([\n                animationPromises[ANIMATION_ENTER_INDEX],\n                hideLeaveSlideAfterAnimationEnds,\n            ]).then(function() {\n                if (!animationCanceled) {\n                    that.activeIndex = newActiveIndex;\n                    that.currentAnimation = null;\n                }\n\n                that.removeListener(COLLECTION_MANAGER_EVENTS.collectionBeforeChange, onBeforeChange);\n                that.removeListener(COLLECTION_MANAGER_EVENTS.collectionAfterChange, onAfterChange);\n                that.removeListener(SINGLE_SLIDE_CAROUSEL_EVENTS.ON_CANCEL_ANIMATION, cancelAnimationHandler);\n\n                that.eventEmitter.emit(\n                    SINGLE_SLIDE_CAROUSEL_EVENTS.ON_ANIMATION_END,\n                    {} as ISingleSlideCarouselAnimationEndEventArgs,\n                );\n\n                resolve();\n            }).catch(function(err) {\n                reject(err);\n            });\n        });\n\n        return {\n            animationPromises: animationPromises,\n            partEndEventAccess: that.engineAnimation.getPartEndListenerAccess(),\n            partStartEventAccess: that.engineAnimation.getPartStartListenerAccess(),\n            soraHandlerStatus: soraHandlerStatus,\n        };\n    }\n}\n","import { CollectionChangeEventArgs } from './collection-change-args';\r\n\r\nexport class CancelableCollectionChangeEventArgs<T> extends CollectionChangeEventArgs<T> {\r\n    /**\r\n     * Creates a new instance.\r\n     * @param indexMap Index map, from old indexes to new indexes.\r\n     * @param newElements New Elements array.\r\n     */\r\n    public constructor(indexMap: {[oldIndex: number]: number}, newElements: T[]) {\r\n        super(indexMap, newElements, false);\r\n    }\r\n\r\n    /**\r\n     * Sets the prevent default action flag to true.\r\n     */\r\n    public setPreventDefault(): void {\r\n        this.preventDefault = true;\r\n    }\r\n}\r\n","export class CollectionChangeEventArgs<T> {\r\n    /**\r\n     * Map from old indexes to new indexes\r\n     */\r\n    protected indexMap: {[oldIndex: number]: number};\r\n    /**\r\n     * new Elements array\r\n     */\r\n    protected newElements: T[];\r\n\r\n    /**\r\n     * Flag to prevent the default action (update the collection)\r\n     */\r\n    protected preventDefault: boolean;\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     * @param indexMap Index map, from old indexes to new indexes.\r\n     * @param newElements New Elements array.\r\n     */\r\n    public constructor(indexMap: {[oldIndex: number]: number}, newElements: T[], preventDefault: boolean) {\r\n        this.indexMap = indexMap;\r\n        this.newElements = newElements;\r\n        this.preventDefault = preventDefault;\r\n    }\r\n\r\n    /**\r\n     * Returns a clone copy of the index map.\r\n     * The index map keys are the old indexes of the collection.\r\n     * The index map values are the new indexes for the old ones.\r\n     */\r\n    public getIndexMap(): {[oldIndex: number]: number} {\r\n        return Object.assign({}, this.indexMap);\r\n    }\r\n\r\n    /**\r\n     * Returns a clone copy of the collection that could be the new collection.\r\n     */\r\n    public getNewElements(): {[index: number]: T} {\r\n        return Object.assign({}, this.newElements);\r\n    }\r\n\r\n    /**\r\n     * Returns the prevent default action flag.\r\n     */\r\n    public getPreventDefault(): boolean {\r\n        return this.preventDefault;\r\n    }\r\n}\r\n","import { EventEmitter } from 'events';\r\nimport { CancelableCollectionChangeEventArgs } from './cancelable-collection-change-args';\r\nimport { CollectionChangeEventArgs } from './collection-change-args';\r\n\r\nexport const COLLECTION_MANAGER_EVENTS = {\r\n    collectionAfterChange: 'coll.ch.a',\r\n    collectionBeforeChange: 'coll.ch.b',\r\n};\r\n\r\n/**\r\n * Collection manager.\r\n * Handles a collection of items and emits events on modifications of the managed collection.\r\n */\r\nexport class CollectionManager<T> {\r\n\r\n    /**\r\n     * Collection to manage\r\n     */\r\n    protected collection: T[];\r\n\r\n    /**\r\n     * Event emitter used to emit events\r\n     */\r\n    protected eventEmitter: EventEmitter;\r\n\r\n    /**\r\n     * Creates a new instance of the class.\r\n     * @param collection Collection to manage.\r\n     * @param eventEmitter Event emitter used to emit events.\r\n     */\r\n    public constructor(collection: T[], eventEmitter: EventEmitter) {\r\n        this.collection = collection;\r\n        this.eventEmitter = eventEmitter;\r\n    }\r\n\r\n    //#region Public\r\n\r\n    /**\r\n     * Returns the collection of elements managed.\r\n     * This is the real collection managed by the instance.\r\n     * Only read operations should be performed directly in the collection.\r\n     */\r\n    public getCollection(): T[] {\r\n        return this.collection;\r\n    }\r\n\r\n    /**\r\n     * Obtains the length of the collection.\r\n     * @returns Length of the collection managed.\r\n     */\r\n    public getLength(): number {\r\n        return this.collection.length;\r\n    }\r\n\r\n    /**\r\n     * Inserts a collection of elements at the selected indexes.\r\n     * @param elements Collection of index-element pairs representing the elements to be inserted.\r\n     */\r\n    public insertElements(elements: {[index: number]: T}): void {\r\n        this.internalInsertElements(elements);\r\n    }\r\n\r\n    /**\r\n     * Removes elements of the collection.\r\n     * @param indexes Indexes of the collection to be removed.\r\n     */\r\n    public removeElements(indexes: number[]): void {\r\n        this.internalRemoveElements(indexes);\r\n    }\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Inserts a collection of elements at the selected indexes.\r\n     * @param elements Collection of index-element pairs representing the elements to be inserted.\r\n     */\r\n    protected internalInsertElements(elements: {[index: number]: T}): void {\r\n        var keys: number[] = new Array();\r\n        for (const elemIndex in elements) {\r\n            if (elements.hasOwnProperty(elemIndex)) {\r\n                const numberElemIndex = Number(elemIndex);\r\n                if (numberElemIndex < 0) {\r\n                    throw new Error('The index param should be greater or equals zero.');\r\n                }\r\n\r\n                if (numberElemIndex > this.collection.length) {\r\n                    throw new Error(\r\n                        'The index param should be less or equals the number of elements of the collection.',\r\n                    );\r\n                }\r\n                keys.push(numberElemIndex);\r\n            }\r\n        }\r\n\r\n        keys = keys.sort(function(number1, number2) {\r\n            return number1 - number2;\r\n        });\r\n\r\n        if (0 === keys.length) {\r\n            return;\r\n        }\r\n\r\n        const newElements: T[] = new Array(this.collection.length + keys.length);\r\n        const indexMap: {[oldIndex: number]: number} = {};\r\n\r\n        if (1 === keys.length) {\r\n            const index = keys[0];\r\n            const element = elements[index];\r\n\r\n            for (var i = 0; i < index; ++i) {\r\n                newElements[i] = this.collection[i];\r\n                indexMap[i] = i;\r\n            }\r\n\r\n            newElements[index] = element;\r\n\r\n            for (var i = index + 1; i < newElements.length; ++i) {\r\n                newElements[i] = this.collection[i - 1];\r\n                indexMap[i - 1] = i;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < keys[0]; ++i) {\r\n                newElements[i] = this.collection[i];\r\n                indexMap[i] = i;\r\n            }\r\n\r\n            newElements[keys[0]] = elements[keys[0]];\r\n\r\n            for (var i = 1; i < keys.length; ++i) {\r\n                const indexPrevious = keys[i - 1];\r\n                const index = keys[i];\r\n                for (var j = indexPrevious + 1; j < index; ++j) {\r\n                    newElements[j] = this.collection[j - i];\r\n                    indexMap[j - i] = j;\r\n                }\r\n\r\n                newElements[index] = elements[index];\r\n            }\r\n\r\n            for (var i = keys[keys.length - 1] + 1; i < newElements.length; ++i) {\r\n                newElements[i] = this.collection[i - keys.length];\r\n                indexMap[i - keys.length] = i;\r\n            }\r\n        }\r\n\r\n        this.internalTryToChangeCollection(indexMap, newElements);\r\n    }\r\n\r\n    /**\r\n     * Removes elements of the collection.\r\n     * @param indexes Indexes of the collection to be removed.\r\n     */\r\n    protected internalRemoveElements(indexes: number[]): void {\r\n        // Sort indexes.\r\n        indexes = indexes.sort(function(number1, number2) {\r\n            return number1 - number2;\r\n        });\r\n\r\n        const indexMap: {[oldIndex: number]: number} = {};\r\n        const newElements: T[] = new Array();\r\n        var counter = 0;\r\n        for (var i = 0; i < this.collection.length; ++i) {\r\n            if (i === indexes[counter]) {\r\n                ++counter;\r\n            } else {\r\n                newElements[i - counter] = this.collection[i];\r\n                indexMap[i] = i - counter;\r\n            }\r\n        }\r\n\r\n        this.internalTryToChangeCollection(indexMap, newElements);\r\n    }\r\n\r\n    /**\r\n     * Attemps to change the collection managed by this instance.\r\n     * @param indexMap Map from old indexes to new indexes.\r\n     * @param newElements New elements to manage if the change is not prevented.\r\n     */\r\n    protected internalTryToChangeCollection(\r\n        indexMap: {[oldIndex: number]: number} = {},\r\n        newElements: T[],\r\n    ): CollectionChangeEventArgs<T> {\r\n        const cancelableChangeEventArgs = new CancelableCollectionChangeEventArgs(indexMap, newElements);\r\n        this.eventEmitter.emit(COLLECTION_MANAGER_EVENTS.collectionBeforeChange, cancelableChangeEventArgs);\r\n\r\n        if (!cancelableChangeEventArgs.getPreventDefault()) {\r\n            this.collection = newElements;\r\n        }\r\n\r\n        const changeEventArgs = new CollectionChangeEventArgs<T>(\r\n            indexMap,\r\n            newElements,\r\n            cancelableChangeEventArgs.getPreventDefault(),\r\n        );\r\n        this.eventEmitter.emit(COLLECTION_MANAGER_EVENTS.collectionAfterChange, changeEventArgs);\r\n        return changeEventArgs;\r\n    }\r\n}\r\n","import { EventEmitter } from 'events';\r\nimport { CollectionChangeEventArgs } from './collection-change-args';\r\nimport { CollectionManager } from './collection-manager';\r\n\r\nexport class HtmlChildrenManager extends CollectionManager<HTMLElement> {\r\n    /**\r\n     * Parent element of the members of the collection\r\n     */\r\n    protected parentElement: HTMLElement;\r\n\r\n    public constructor(collection: HTMLElement[], eventEmitter: EventEmitter, parentElement: HTMLElement) {\r\n        super(collection, eventEmitter);\r\n\r\n        this.parentElement = parentElement;\r\n    }\r\n\r\n    /**\r\n     * Attemps to change the collection managed by this instance.\r\n     * @param indexMap Map from old indexes to new indexes.\r\n     * @param newElements New elements to manage if the change is not prevented.\r\n     */\r\n    protected internalTryToChangeCollection(\r\n        indexMap: {[oldIndex: number]: number} = {},\r\n        newElements: HTMLElement[],\r\n    ): CollectionChangeEventArgs<HTMLElement> {\r\n        const eventArgs = super.internalTryToChangeCollection(indexMap, newElements);\r\n\r\n        if (!eventArgs.getPreventDefault()) {\r\n            // Perform DOM modifications.\r\n            var deletionPivot = 0;\r\n            var insertionPivot = 0;\r\n            var oldIndexesCounter = 0;\r\n            var newIndexesCounter = 0;\r\n\r\n            // Important: Keys must be guaranteed to be ordered!\r\n            for (const key in indexMap) {\r\n                if (indexMap.hasOwnProperty(key)) {\r\n                    const keyNumber: number = Number(key);\r\n                    for (var i = oldIndexesCounter; i < keyNumber; ++i) {\r\n                        // Delete old elements\r\n                        this.parentElement.removeChild(this.parentElement.children[i + insertionPivot - deletionPivot]);\r\n                        ++deletionPivot;\r\n                    }\r\n\r\n                    const newIndex: number = indexMap[key];\r\n                    for (var i = newIndexesCounter; i < newIndex; ++i) {\r\n                        // Insert new elements.\r\n                        this.parentElement.insertBefore(newElements[i], this.parentElement.children[i]);\r\n                        ++insertionPivot;\r\n                    }\r\n\r\n                    oldIndexesCounter = keyNumber + 1;\r\n                    newIndexesCounter = newIndex + 1;\r\n                }\r\n            }\r\n\r\n            for (var i = newIndexesCounter; i < newElements.length; ++i) {\r\n                this.parentElement.appendChild(newElements[i]);\r\n            }\r\n        }\r\n\r\n        return eventArgs;\r\n    }\r\n}\r\n","export class TokenMap<T> {\r\n    //#region Properties\r\n\r\n    /**\r\n     * Inner map.\r\n     */\r\n    protected innerMap: Map<number, T>;\r\n\r\n    /**\r\n     * List of unused indexed bellow the maximun used index.\r\n     */\r\n    protected unusedIndexes: number[];\r\n\r\n    //#endregion\r\n\r\n    public constructor() {\r\n        this.innerMap = new Map<number, T>();\r\n        this.unusedIndexes = new Array();\r\n    }\r\n\r\n    /**\r\n     * Adds an element to the array collection.\r\n     * @param elem Element to be added to the array.\r\n     * @returns index in which the element is located.\r\n     */\r\n    public add(elem: T): number {\r\n        if (0 === this.unusedIndexes.length) {\r\n            const lastIndex: number = this.innerMap.size;\r\n            this.innerMap.set(lastIndex, elem);\r\n            return lastIndex;\r\n        } else {\r\n            const lastIndex: number = this.unusedIndexes[this.unusedIndexes.length - 1];\r\n            --this.unusedIndexes.length;\r\n            this.innerMap.set(lastIndex, elem);\r\n            return lastIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains the amount of elements inside the array.\r\n     * @returns Amount of elements inside the array.\r\n     */\r\n    public count(): number {\r\n        return this.innerMap.size;\r\n    }\r\n\r\n    /**\r\n     * Iterates over the array and applies a function.\r\n     * @param consumer Function to apply to any pair of index-element found (undefined values are discarted).\r\n     */\r\n    public foreach(consumer: (value: T, key: number) => void): void {\r\n        this.innerMap.forEach(function(value: T, key: number) {\r\n            consumer(value, key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Obtains an element at the specified index.\r\n     * @param index Index of the element to obtaint.\r\n     * @returns Element obtianed at the specified index.\r\n     */\r\n    public get(index: number): T {\r\n        return this.innerMap.get(index);\r\n    }\r\n\r\n    /**\r\n     * Removes an element at the position specified.\r\n     * @param index Index of the element to be removed.\r\n     * @returns Result of the operation.\r\n     */\r\n    public remove(index: number): boolean {\r\n        if (this.innerMap.has(index)) {\r\n            this.innerMap.delete(index);\r\n            this.unusedIndexes[this.unusedIndexes.length] = index;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","require('core-js/fn/promise');\n\nimport {\n    SINGLE_SLIDE_CAROUSEL_ACTIONS,\n    SINGLE_SLIDE_CAROUSEL_EVENTS,\n    SINGLE_SLIDE_CAROUSEL_STYLES,\n    SingleSlideCarousel,\n } from './carousel/single-slide/single-slide-carousel';\n\nconst sora = function() {\n    return {\n        SingleSlideCarousel: SingleSlideCarousel,\n        actions: {\n            SINGLE_SLIDE_CAROUSEL_ACTIONS : SINGLE_SLIDE_CAROUSEL_ACTIONS,\n        },\n        events: {\n            SINGLE_SLIDE_CAROUSEL_EVENTS : SINGLE_SLIDE_CAROUSEL_EVENTS,\n        },\n        styles: {\n            SINGLE_SLIDE_CAROUSEL_STYLES : SINGLE_SLIDE_CAROUSEL_STYLES,\n        },\n    };\n} ();\n\nmodule.exports = sora;\n","/**\r\n * Constraint that determines the start of the task part.\r\n */\r\nexport interface ITaskPartWhenConstraint {\r\n    /**\r\n     * When entity to check once this constraint is ensured.\r\n     */\r\n    after: ITaskPartWhenConstraint;\r\n    /**\r\n     * Type of this constraint.\r\n     */\r\n    constraintType: string;\r\n}\r\n\r\n/**\r\n * Constraint that determines the start of the task part.\r\n */\r\nexport abstract class TaskPartWhenConstraint implements ITaskPartWhenConstraint {\r\n    /**\r\n     * When entity to check once this constraint is ensured.\r\n     */\r\n    public after: ITaskPartWhenConstraint;\r\n    /**\r\n     * Type of this constraint.\r\n     */\r\n    public constraintType: string;\r\n\r\n    /**\r\n     * Creates a new task part constraint.\r\n     * @param after Constraint to apply after this constraint is checked.\r\n     * @param constraintType Constraint type.\r\n     */\r\n    public constructor(after: ITaskPartWhenConstraint, constraintType: string) {\r\n        this.after = after;\r\n        this.constraintType = constraintType;\r\n    }\r\n}\r\n","import {\r\n    ITaskPartWhenConstraint,\r\n    TaskPartWhenConstraint,\r\n} from './task-flow-when';\r\n\r\n/**\r\n * Task constraint types\r\n */\r\nexport const TASK_CONSTRAINT_TYPES = {\r\n    /**\r\n     * Requires the end of a task part.\r\n     */\r\n    END: 'anim.end',\r\n    /**\r\n     * Requires a group of constraints.\r\n     */\r\n    GROUP: 'group',\r\n    /**\r\n     * Requires the start of a task part.\r\n     */\r\n    START : 'anim.start',\r\n    /**\r\n     * Requires an amount of time.\r\n     */\r\n    WAIT_FOR: 'wait',\r\n};\r\n\r\nexport abstract class TaskPartConstraint extends TaskPartWhenConstraint {\r\n    /**\r\n     * Alias of the part affected by this constraint.\r\n     */\r\n    public alias: string;\r\n\r\n    /**\r\n     * Creates a new task part constraint.\r\n     * @param after Constraint to apply after this constraint is checked.\r\n     * @param alias Aliases of the parts affected by this constraint.\r\n     * @param constraintType Constraint type.\r\n     */\r\n    public constructor(after: ITaskPartWhenConstraint, alias: string, constraintType: string) {\r\n        super(after, constraintType);\r\n\r\n        this.alias = alias;\r\n    }\r\n}\r\n","import { EventEmitter } from 'events';\r\nimport { TokenMap } from '../../collection/token-map';\r\nimport { IOperationManagerAccess } from './operation-manager-access';\r\n\r\n/**\r\n * Operation arguments\r\n */\r\nexport interface IOperationArgs {\r\n    aliases: string[];\r\n}\r\n\r\n/**\r\n * Represents an operation manager. The operation is propagated using an event.\r\n * All the subscribers\r\n */\r\nexport class OperationManager<Args extends IOperationArgs> implements IOperationManagerAccess<Args> {\r\n\r\n    //#region Attributes\r\n\r\n    /**\r\n     * Function to be called to handle the event.\r\n     */\r\n    protected callFunction: (eventArgs: Args) => void;\r\n\r\n    /**\r\n     * Alias of the event.\r\n     */\r\n    protected eventAlias: string;\r\n\r\n    /**\r\n     * Event emmitter of the event.\r\n     */\r\n    protected eventEmitter: EventEmitter;\r\n\r\n    /**\r\n     * Object to storage all the functions subscribed.\r\n     */\r\n    protected subscriptionStorage: { [alias: string]: TokenMap<(eventArgs: Args) => void> };\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Creates a new operation manager\r\n     * @param eventAlias Event alias.\r\n     * @param eventEmitter Event emitter.\r\n     */\r\n    public constructor(eventAlias: string, eventEmitter: EventEmitter) {\r\n        const that = this;\r\n        this.callFunction = function(eventArgs: Args): void {\r\n            if (eventArgs.aliases == null) {\r\n                for (const alias in that.subscriptionStorage) {\r\n                    if (that.subscriptionStorage.hasOwnProperty(alias)) {\r\n                        const subscribers = that.subscriptionStorage[alias];\r\n                        if (subscribers != null) {\r\n                            subscribers.foreach(function(value: (eventArgs: Args) => void) {\r\n                                value(eventArgs);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                for (const alias of eventArgs.aliases) {\r\n                    const subscribers = that.subscriptionStorage[alias];\r\n                    if (subscribers != null) {\r\n                        subscribers.foreach(function(value: (eventArgs: Args) => void) {\r\n                            value(eventArgs);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this.eventAlias = eventAlias;\r\n        this.eventEmitter = eventEmitter;\r\n        this.subscriptionStorage = {};\r\n\r\n        this.eventEmitter.addListener(this.eventAlias, this.callFunction);\r\n    }\r\n\r\n    /**\r\n     * Disposes the instance.\r\n     */\r\n    public dispose(): void {\r\n        this.eventEmitter.removeListener(this.eventAlias, this.callFunction);\r\n    }\r\n\r\n    /**\r\n     * Substribes a handler under an alias.\r\n     * @param alias Alias of the handler.\r\n     * @param handler Handler to be subscribed.\r\n     */\r\n    public subscribe(alias: string, handler: (eventArgs: Args) => void): number {\r\n        if (null == this.subscriptionStorage[alias]) {\r\n            this.subscriptionStorage[alias] = new TokenMap();\r\n        }\r\n        return this.subscriptionStorage[alias].add(handler);\r\n    }\r\n\r\n    /**\r\n     * Unsubscribes a handler under an alias.\r\n     * @param alias Alias of the handler.\r\n     * @param index Index of the handler.\r\n     */\r\n    public unsubscribe(alias: string, index: number): boolean {\r\n        if (null == this.subscriptionStorage[alias]) {\r\n            return false;\r\n        } else {\r\n            return this.subscriptionStorage[alias].remove(index);\r\n        }\r\n    }\r\n}\r\n","import { EventEmitter } from 'events';\r\nimport { ITaskFlow } from './flow/task-flow';\r\nimport { ITaskFlowPart } from './flow/task-flow-part';\r\nimport {\r\n    ITaskFlowPartEndArgs,\r\n    ITaskFlowPartStartArgs,\r\n} from './flow/task-flow-part-event-args';\r\nimport { ITaskPartWhenConstraint } from './flow/task-flow-when';\r\nimport { TaskPartBeginConstraint } from './flow/task-part-begin-constraint';\r\nimport { TASK_CONSTRAINT_TYPES } from './flow/task-part-constraint';\r\nimport { TaskPartEndConstraint } from './flow/task-part-end-constraint';\r\nimport { TaskGroupConstraint } from './flow/task-part-group-constraint';\r\nimport { TaskTimeConstraint } from './flow/task-part-time-constraint';\r\nimport { OperationManager } from './operation/operation-manager';\r\nimport { IOperationManagerAccess } from './operation/operation-manager-access';\r\nimport { TASK_PART_WHEN_EVENTS } from './task-part-when-events';\r\nimport { TaskPartWhenOperator } from './task-part-when-operator';\r\n\r\n/**\r\n * Represents a task engine.\r\n */\r\nexport abstract class TaskEngine<TPart extends ITaskFlowPart> {\r\n    //#region Attributes\r\n\r\n    /**\r\n     * Task currently managed.\r\n     */\r\n    protected currentTask: ITaskFlow<TPart>;\r\n\r\n    /**\r\n     * Event emitter to use\r\n     */\r\n    protected eventEmitter: EventEmitter;\r\n\r\n    //#region Operations\r\n\r\n    /**\r\n     * Manager that handles the part end event.\r\n     */\r\n    protected partEndManager: OperationManager<ITaskFlowPartEndArgs<TPart>>;\r\n\r\n    /**\r\n     * Manager that handles the part start event.\r\n     */\r\n    protected partStartManager: OperationManager<ITaskFlowPartStartArgs<TPart>>;\r\n\r\n    //#endregion\r\n\r\n    //#endregion\r\n\r\n    //#region Public\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     */\r\n    public constructor() {\r\n        this.eventEmitter = new EventEmitter();\r\n\r\n        this.partEndManager = new OperationManager<ITaskFlowPartEndArgs<TPart>>(\r\n            TASK_PART_WHEN_EVENTS.END,\r\n            this.eventEmitter,\r\n        );\r\n        this.partStartManager = new OperationManager<ITaskFlowPartStartArgs<TPart>>(\r\n            TASK_PART_WHEN_EVENTS.START,\r\n            this.eventEmitter,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Obtains the access of the part end event.\r\n     * @returns Access of the part end event.\r\n     */\r\n    public getPartEndListenerAccess(): IOperationManagerAccess<ITaskFlowPartEndArgs<TPart>> {\r\n        const that = this;\r\n        return {\r\n            subscribe: function(\r\n                alias: string,\r\n                handler: (eventArgs: ITaskFlowPartEndArgs<TPart>) => void,\r\n            ): number {\r\n                return that.partEndManager.subscribe(alias, handler);\r\n            },\r\n            unsubscribe: function(alias: string, index: number): boolean {\r\n                return that.partEndManager.unsubscribe(alias, index);\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Obtains the access of the part start event.\r\n     * @returns Access of the part start event.\r\n     */\r\n    public getPartStartListenerAccess(): IOperationManagerAccess<ITaskFlowPartStartArgs<TPart>> {\r\n        const that = this;\r\n        return {\r\n            subscribe: function(\r\n                alias: string,\r\n                handler: (eventArgs: ITaskFlowPartStartArgs<TPart>) => void,\r\n            ): number {\r\n                return that.partStartManager.subscribe(alias, handler);\r\n            },\r\n            unsubscribe: function(alias: string, index: number): boolean {\r\n                return that.partStartManager.unsubscribe(alias, index);\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Handles a task flow.\r\n     * @param taskFlow Task flow to be managed.\r\n     * @returns Task part promises.\r\n     */\r\n    public handle(taskFlow: ITaskFlow<TPart>): Array<Promise<void>> {\r\n        if (taskFlow == null) {\r\n            throw new Error('It\\'s required a task flow.');\r\n        }\r\n        if (taskFlow.parts == null) {\r\n            throw new Error('It\\'s required a task flow with parts.');\r\n        }\r\n\r\n        this.currentTask = taskFlow;\r\n        const partPromises: Array<Promise<void>> = new Array(taskFlow.parts.length);\r\n\r\n        for (var i = 0; i < taskFlow.parts.length; ++i) {\r\n            partPromises[i] = this.handleTaskPart(taskFlow.parts[i]);\r\n        }\r\n\r\n        return partPromises;\r\n    }\r\n\r\n    //#endregion\r\n\r\n    /**\r\n     * Handles a task part.\r\n     *\r\n     * @param part Task part to handle.\r\n     *\r\n     * @returns Promise resolved once the part of the task is finished.\r\n     */\r\n    protected handleTaskPart(part: TPart): Promise<void> {\r\n        const that = this;\r\n\r\n        return new Promise<void>(function(resolve, reject) {\r\n            that.handleTaskPartWhen(part.when).then(function() {\r\n                // 1. Emit the start of task part.\r\n                that.eventEmitter.emit(\r\n                    TASK_PART_WHEN_EVENTS.START,\r\n                    {\r\n                        aliases: [part.alias],\r\n                        part: part,\r\n                    } as ITaskFlowPartStartArgs<TPart>,\r\n                );\r\n\r\n                const promise: PromiseLike<{} | void> = that.performTask(part);\r\n\r\n                promise.then(function() {\r\n                    // 3. Emit the end of the task part and resolve the promise.\r\n                    that.eventEmitter.emit(\r\n                        TASK_PART_WHEN_EVENTS.END,\r\n                        {\r\n                            aliases: [part.alias],\r\n                            part: part,\r\n                        } as ITaskFlowPartEndArgs<TPart>,\r\n                    );\r\n                    resolve();\r\n                });\r\n            }).catch(function(err: any) {\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Performs a task part.\r\n     * @param part Task part to be performed.\r\n     * @returns Promise resolved once the part task is performed.\r\n     */\r\n    protected abstract performTask(part: TPart): PromiseLike<{} | void>;\r\n\r\n    //#region TaskPartWhenconstraint\r\n\r\n    /**\r\n     * Handles the when entity of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     *\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhen(whenEntity: ITaskPartWhenConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            if (null == whenEntity) {\r\n                resolve();\r\n            } else {\r\n                switch (whenEntity.constraintType) {\r\n                    case TASK_CONSTRAINT_TYPES.START:\r\n                        that.handleTaskPartWhenPartBegins(whenEntity as TaskPartBeginConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    case TASK_CONSTRAINT_TYPES.END:\r\n                        that.handleTaskPartWhenPartEnds(whenEntity as TaskPartEndConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    case TASK_CONSTRAINT_TYPES.GROUP:\r\n                        that.handleTaskPartWhenPartGroup(whenEntity as TaskGroupConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    case TASK_CONSTRAINT_TYPES.WAIT_FOR:\r\n                        that.handleTaskPartWhenWaitFor(whenEntity as TaskTimeConstraint)\r\n                            .then(resolve);\r\n                        break;\r\n                    default:\r\n                        throw new Error('Unexpected when entity type.');\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskPartBeginConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenPartBegins(whenEntity: TaskPartBeginConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            const eventHandler = function() {\r\n                that.partStartManager.unsubscribe(whenEntity.alias, token);\r\n                if (null == whenEntity.after) {\r\n                    resolve();\r\n                } else {\r\n                    that.handleTaskPartWhen(whenEntity.after)\r\n                        .then(resolve);\r\n                }\r\n            };\r\n            const token: number = that.partStartManager.subscribe(whenEntity.alias, eventHandler);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskPartEndConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenPartEnds(whenEntity: TaskPartEndConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            const eventHandler = function() {\r\n                that.partEndManager.unsubscribe(whenEntity.alias, token);\r\n                if (null == whenEntity.after) {\r\n                    resolve();\r\n                } else {\r\n                    that.handleTaskPartWhen(whenEntity.after)\r\n                        .then(resolve);\r\n                }\r\n            };\r\n            const token: number = that.partEndManager.subscribe(whenEntity.alias, eventHandler);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskGroupConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     *\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenPartGroup(whenEntity: TaskGroupConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            const childPromises: Array<Promise<void>> = new Array(whenEntity.constraints.length);\r\n\r\n            for (var i = 0; i < whenEntity.constraints.length; ++i) {\r\n                childPromises[i] = new Promise<void>(function(resolve, reject) {\r\n                    that.handleTaskPartWhen(whenEntity.constraints[i])\r\n                        .then(resolve);\r\n                });\r\n            }\r\n\r\n            if (TaskPartWhenOperator.AND === whenEntity.operator) {\r\n                Promise.all(childPromises)\r\n                    .then(function() {\r\n                        resolve();\r\n                    });\r\n            } else if (TaskPartWhenOperator.OR === whenEntity.operator) {\r\n                Promise.race(childPromises)\r\n                .then(function() {\r\n                    resolve();\r\n                });\r\n            } else {\r\n                reject('Unexpected operator.');\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles the when entity (TaskTimeConstraint) of a task part.\r\n     *\r\n     * @param whenEntity When entity to handle.\r\n     *\r\n     * @returns Promise resolved once the when entity is checked.\r\n     */\r\n    protected handleTaskPartWhenWaitFor(whenEntity: TaskTimeConstraint): Promise<void> {\r\n        const that = this;\r\n        return new Promise<void>(function(resolve, reject) {\r\n            setTimeout(function() {\r\n                if (whenEntity.after == null) {\r\n                    resolve();\r\n                } else {\r\n                    that.handleTaskPartWhen(whenEntity.after)\r\n                        .then(resolve);\r\n                }\r\n            }, whenEntity.millis);\r\n        });\r\n    }\r\n\r\n    //#endregion\r\n}\r\n","/**\r\n * Prefixes used to ganerate alias for events over task parts.\r\n */\r\nexport const TASK_PART_WHEN_EVENTS = {\r\n    /**\r\n     * Prefix for any event raised once a task part is ended.\r\n     */\r\n    END: 'part.end',\r\n    /**\r\n     * Prefix for any event raised once a task part is started.\r\n     */\r\n    START: 'part.start',\r\n};\r\n","/**\r\n * Logical operator to apply.\r\n */\r\nexport enum TaskPartWhenOperator {\r\n    /**\r\n     * And operator.\r\n     */\r\n    AND,\r\n    /**\r\n     * Or operator.\r\n     */\r\n    OR,\r\n}\r\n","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","require('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.promise');\nrequire('../modules/es7.promise.finally');\nrequire('../modules/es7.promise.try');\nmodule.exports = require('../modules/_core').Promise;\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var core = module.exports = { version: '2.6.0' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = {};\n","module.exports = false;\n","var global = require('./_global');\nvar macrotask = require('./_task').set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = require('./_cof')(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n","'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = require('./_a-function');\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n","var anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar newPromiseCapability = require('./_new-promise-capability');\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var redefine = require('./_redefine');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n","'use strict';\nvar global = require('./_global');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'\n});\n","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","var ctx = require('./_ctx');\nvar invoke = require('./_invoke');\nvar html = require('./_html');\nvar cel = require('./_dom-create');\nvar global = require('./_global');\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (require('./_cof')(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var global = require('./_global');\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar classof = require('./_classof');\nvar test = {};\ntest[require('./_wks')('toStringTag')] = 'z';\nif (test + '' != '[object z]') {\n  require('./_redefine')(Object.prototype, 'toString', function toString() {\n    return '[object ' + classof(this) + ']';\n  }, true);\n}\n","'use strict';\nvar LIBRARY = require('./_library');\nvar global = require('./_global');\nvar ctx = require('./_ctx');\nvar classof = require('./_classof');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar aFunction = require('./_a-function');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar speciesConstructor = require('./_species-constructor');\nvar task = require('./_task').set;\nvar microtask = require('./_microtask')();\nvar newPromiseCapabilityModule = require('./_new-promise-capability');\nvar perform = require('./_perform');\nvar userAgent = require('./_user-agent');\nvar promiseResolve = require('./_promise-resolve');\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n","'use strict';\nvar $at = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n","// https://github.com/tc39/proposal-promise-finally\n'use strict';\nvar $export = require('./_export');\nvar core = require('./_core');\nvar global = require('./_global');\nvar speciesConstructor = require('./_species-constructor');\nvar promiseResolve = require('./_promise-resolve');\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n","'use strict';\n// https://github.com/tc39/proposal-promise-try\nvar $export = require('./_export');\nvar newPromiseCapability = require('./_new-promise-capability');\nvar perform = require('./_perform');\n\n$export($export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = newPromiseCapability.f(this);\n  var result = perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2pzL3RtcC9zcmMvYW5pbWF0aW9uL2FuaW1hdGlvbi1lbmdpbmUudHMiLCJkaXN0L2pzL3RtcC9zcmMvYW5pbWF0aW9uL2FuaW1hdGlvbi1vcGVyYXRpb24tZXZlbnRzLnRzIiwiZGlzdC9qcy90bXAvc3JjL2FuaW1hdGlvbi9hbmltYXRpb24tcGxheS1zdGF0ZS50cyIsImRpc3QvanMvdG1wL3NyYy9jYXJvdXNlbC9jYXJvdXNlbC1iYXNlLnRzIiwiZGlzdC9qcy90bXAvc3JjL2Nhcm91c2VsL3NpbmdsZS1zbGlkZS9zaW5nbGUtc2xpZGUtY2Fyb3VzZWwudHMiLCJkaXN0L2pzL3RtcC9zcmMvY29sbGVjdGlvbi9jYW5jZWxhYmxlLWNvbGxlY3Rpb24tY2hhbmdlLWFyZ3MudHMiLCJkaXN0L2pzL3RtcC9zcmMvY29sbGVjdGlvbi9jb2xsZWN0aW9uLWNoYW5nZS1hcmdzLnRzIiwiZGlzdC9qcy90bXAvc3JjL2NvbGxlY3Rpb24vY29sbGVjdGlvbi1tYW5hZ2VyLnRzIiwiZGlzdC9qcy90bXAvc3JjL2NvbGxlY3Rpb24vaHRtbC1jaGlsZHJlbi1tYW5hZ2VyLnRzIiwiZGlzdC9qcy90bXAvc3JjL2NvbGxlY3Rpb24vdG9rZW4tbWFwLnRzIiwiZGlzdC9qcy90bXAvc3JjL21haW4udHMiLCJkaXN0L2pzL3RtcC9zcmMvdGFzay9mbG93L3Rhc2stZmxvdy13aGVuLnRzIiwiZGlzdC9qcy90bXAvc3JjL3Rhc2svZmxvdy90YXNrLXBhcnQtY29uc3RyYWludC50cyIsImRpc3QvanMvdG1wL3NyYy90YXNrL29wZXJhdGlvbi9vcGVyYXRpb24tbWFuYWdlci50cyIsImRpc3QvanMvdG1wL3NyYy90YXNrL3Rhc2stZW5naW5lLnRzIiwiZGlzdC9qcy90bXAvc3JjL3Rhc2svdGFzay1wYXJ0LXdoZW4tZXZlbnRzLnRzIiwiZGlzdC9qcy90bXAvc3JjL3Rhc2svdGFzay1wYXJ0LXdoZW4tb3BlcmF0b3IudHMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEJhc2UuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191c2VyLWFnZW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOztJQU1hLHFCOzs7OztBQW1CVCxtQ0FBQTtBQUFBOztBQUFBO0FBQ0k7QUFFQSxVQUFLLHNCQUFMLEdBQ0ksSUFBSSxrQ0FBSixDQUNJLHFEQUEyQixnQkFEL0IsRUFFSSxNQUFLLFlBRlQsQ0FESjtBQUtBLFVBQUssMkJBQUwsR0FDSSxJQUFJLGtDQUFKLENBQ0kscURBQTJCLHNCQUQvQixFQUVJLE1BQUssWUFGVCxDQURKO0FBUko7QUFhQzs7Ozs4QkFPYTtBQUNWLFdBQUssc0JBQUwsQ0FBNEIsT0FBNUI7QUFDQSxXQUFLLDJCQUFMLENBQWlDLE9BQWpDO0FBQ0g7OztvQ0FRc0IsTyxFQUFpQjtBQUNwQyxXQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FDSSxxREFBMkIsZ0JBRC9CLEVBRUk7QUFBRSxRQUFBLE9BQU8sRUFBRztBQUFaLE9BRko7QUFJSDs7OzBCQU1ZLE8sRUFBaUI7QUFDMUIsV0FBSyxZQUFMLENBQWtCLElBQWxCLENBQ0kscURBQTJCLHNCQUQvQixFQUVJO0FBQ0ksUUFBQSxPQUFPLEVBQUUsT0FEYjtBQUVJLFFBQUEsS0FBSyxFQUFFLDRDQUF3QjtBQUZuQyxPQUZKO0FBT0g7OzsyQkFNYSxPLEVBQWlCO0FB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Q0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImltcG9ydCB7IENBUk9VU0VMX1NUWUxFUyB9IGZyb20gJy4uL2Nhcm91c2VsL2Nhcm91c2VsLWJhc2UnO1xyXG5pbXBvcnQgeyBPcGVyYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vdGFzay9vcGVyYXRpb24vb3BlcmF0aW9uLW1hbmFnZXInO1xyXG5pbXBvcnQgeyBUYXNrRW5naW5lIH0gZnJvbSAnLi4vdGFzay90YXNrLWVuZ2luZSc7XHJcbmltcG9ydCB7IElBbmltYXRpb25DYW5jZWxFdmVudEFyZ3MgfSBmcm9tICcuL2FuaW1hdGlvbi1jYW5jZWwtZXZlbnQtYXJncyc7XHJcbmltcG9ydCB7IElBbmltYXRpb25GbG93UGFydCB9IGZyb20gJy4vYW5pbWF0aW9uLWZsb3ctcGFydCc7XHJcbmltcG9ydCB7IEFOSU1BVElPTl9PUEVSQVRJT05fRVZFTlRTIH0gZnJvbSAnLi9hbmltYXRpb24tb3BlcmF0aW9uLWV2ZW50cyc7XHJcbmltcG9ydCB7IEFuaW1hdGlvblBsYXlTdGF0ZVZhbHVlIH0gZnJvbSAnLi9hbmltYXRpb24tcGxheS1zdGF0ZSc7XHJcbmltcG9ydCB7IElBbmltYXRpb25TdGF0ZUNoYW5nZUV2ZW50QXJncyB9IGZyb20gJy4vYW5pbWF0aW9uLXN0YXRlLWNoYW5nZS1ldmVudC1hcmdzJztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIGFuaW1hdGlvbiBlbmdpbmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2luZ2xlQW5pbWF0aW9uRW5naW5lIGV4dGVuZHMgVGFza0VuZ2luZTxJQW5pbWF0aW9uRmxvd1BhcnQ+IHtcclxuXHJcbiAgICAvLyNyZWdpb24gQXR0cmlidXRlc1xyXG5cclxuICAgIC8vI3JlZ2lvbiBPcGVyYXRvcnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBjYW5jZWwgb3BlcmF0aW9uIG1hbmFnZXIuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhbmltYXRpb25DYW5jZWxNYW5hZ2VyOiBPcGVyYXRpb25NYW5hZ2VyPElBbmltYXRpb25DYW5jZWxFdmVudEFyZ3M+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIHN0YXRlIGNoYW5nZSBvcGVyYXRpb24gbWFuYWdlci5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFuaW1hdGlvblN0YXRlQ2hhbmdlTWFuYWdlcjogT3BlcmF0aW9uTWFuYWdlcjxJQW5pbWF0aW9uU3RhdGVDaGFuZ2VFdmVudEFyZ3M+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ2FuY2VsTWFuYWdlciA9XHJcbiAgICAgICAgICAgIG5ldyBPcGVyYXRpb25NYW5hZ2VyPElBbmltYXRpb25DYW5jZWxFdmVudEFyZ3M+KFxyXG4gICAgICAgICAgICAgICAgQU5JTUFUSU9OX09QRVJBVElPTl9FVkVOVFMuQU5JTUFUSU9OX0NBTkNFTCxcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGVDaGFuZ2VNYW5hZ2VyID1cclxuICAgICAgICAgICAgbmV3IE9wZXJhdGlvbk1hbmFnZXI8SUFuaW1hdGlvblN0YXRlQ2hhbmdlRXZlbnRBcmdzPihcclxuICAgICAgICAgICAgICAgIEFOSU1BVElPTl9PUEVSQVRJT05fRVZFTlRTLkFOSU1BVElPTl9TVEFURV9DSEFOR0UsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlcixcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gUHVibGljXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ2FuY2VsTWFuYWdlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZUNoYW5nZU1hbmFnZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBPcGVyYXRpb25zXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWxzIHRoZSBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gYWxpYXNlcyBBbGlhc2VzIG9mIHRoZSBwYXJ0cyB0byBjYW5jZWwgb3IgbnVsbCB0byBjYW5jZWwgYWxsIHRoZSBwYXJ0cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbmNlbEFuaW1hdGlvbihhbGlhc2VzOiBzdHJpbmdbXSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXHJcbiAgICAgICAgICAgIEFOSU1BVElPTl9PUEVSQVRJT05fRVZFTlRTLkFOSU1BVElPTl9DQU5DRUwsXHJcbiAgICAgICAgICAgIHsgYWxpYXNlcyA6IGFsaWFzZXMgfSBhcyBJQW5pbWF0aW9uQ2FuY2VsRXZlbnRBcmdzLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMgdGhlIGVuZ2luZSBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gYWxpYXNlcyBBbGlhc2VzIG9mIHRoZSBhbmltYXRpb24gcGFydHMgdG8gcGF1c2Ugb3IgbnVsbCB0byBwYXVzZSBhbGwgdGhlIHBhcnRzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGF1c2UoYWxpYXNlczogc3RyaW5nW10pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFxyXG4gICAgICAgICAgICBBTklNQVRJT05fT1BFUkFUSU9OX0VWRU5UUy5BTklNQVRJT05fU1RBVEVfQ0hBTkdFLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBhbGlhc2VzLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IEFuaW1hdGlvblBsYXlTdGF0ZVZhbHVlLnBhdXNlZCxcclxuICAgICAgICAgICAgfSBhcyBJQW5pbWF0aW9uU3RhdGVDaGFuZ2VFdmVudEFyZ3MsXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3VtZXMgdGhlIGVuZ2luZSBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gYWxpYXNlcyBBbGlhc2VzIG9mIHRoZSBhbmltYXRpb24gcGFydHMgdG8gcmVzdW1lIG9yIG51bGwgdG8gcmVzdW1lIGFsbCB0aGUgcGFydHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXN1bWUoYWxpYXNlczogc3RyaW5nW10pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFxyXG4gICAgICAgICAgICBBTklNQVRJT05fT1BFUkFUSU9OX0VWRU5UUy5BTklNQVRJT05fU1RBVEVfQ0hBTkdFLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBhbGlhc2VzLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IEFuaW1hdGlvblBsYXlTdGF0ZVZhbHVlLnJ1bm5pbmcsXHJcbiAgICAgICAgICAgIH0gYXMgSUFuaW1hdGlvblN0YXRlQ2hhbmdlRXZlbnRBcmdzLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGFuIGFuaW1hdGlvbiBwYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb25GbG93IEFuaW1hdGlvbiBmbG93IHRoYXQgY29udGFpbnMgdGhlIGFubWF0aW9uIHBhcnQgdG8gaGFuZGxlLlxyXG4gICAgICogQHBhcmFtIHBhcnQgQW5pbWF0aW9uIHBhcnQgdG8gaGFuZGxlLlxyXG4gICAgICogQHBhcmFtIGV2ZW50RW1pdHRlciBFdmVudCBlbWl0dGVyIGZvciB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2ZWQgb25jZSB0aGUgYW5pbWF0aW9uIG9mIHRoZSBwYXJ0IGlzIGZpbmlzaGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaGFuZGxlVGFza1BhcnQocGFydDogSUFuaW1hdGlvbkZsb3dQYXJ0KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcGFydC5wZW5kaW5nT3BlcmF0aW9ucyA9IHtcclxuICAgICAgICAgICAgY2FuY2VsOiB7XHJcbiAgICAgICAgICAgICAgICBpc1BlbmRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uVG9rZW46IHRoaXMuYW5pbWF0aW9uQ2FuY2VsTWFuYWdlci5zdWJzY3JpYmUoXHJcbiAgICAgICAgICAgICAgICAgICAgcGFydC5hbGlhcyxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihldmVudEFyZ3M6IElBbmltYXRpb25DYW5jZWxFdmVudEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5wZW5kaW5nT3BlcmF0aW9ucy5jYW5jZWwuaXNQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hbmltYXRpb25DYW5jZWxNYW5hZ2VyLnVuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5hbGlhcywgcGFydC5wZW5kaW5nT3BlcmF0aW9ucy5jYW5jZWwub3BlcmF0aW9uVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhdXNlOiB7XHJcbiAgICAgICAgICAgICAgICBpc1BlbmRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uVG9rZW46IHRoaXMuYW5pbWF0aW9uU3RhdGVDaGFuZ2VNYW5hZ2VyLnN1YnNjcmliZShcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0LmFsaWFzLFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGV2ZW50QXJnczogSUFuaW1hdGlvblN0YXRlQ2hhbmdlRXZlbnRBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQucGVuZGluZ09wZXJhdGlvbnMucGF1c2UuaXNQZW5kaW5nID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXJncy52YWx1ZSA9PT0gQW5pbWF0aW9uUGxheVN0YXRlVmFsdWUucGF1c2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBzdXBlci5oYW5kbGVUYXNrUGFydChwYXJ0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgdGFzayBwYXJ0LlxyXG4gICAgICogQHBhcmFtIHBhcnQgVGFzayBwYXJ0IHRvIGJlIHBlcmZvcm1lZC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2ZWQgb25jZSB0aGUgcGFydCB0YXNrIGlzIHBlcmZvcm1lZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBlcmZvcm1UYXNrKHBhcnQ6IElBbmltYXRpb25GbG93UGFydCk6IFByb21pc2VMaWtlPHt9IHwgdm9pZD4ge1xyXG5cclxuICAgICAgICBpZiAocGFydC5wZW5kaW5nT3BlcmF0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkNhbmNlbE1hbmFnZXIudW5zdWJzY3JpYmUocGFydC5hbGlhcywgcGFydC5wZW5kaW5nT3BlcmF0aW9ucy5jYW5jZWwub3BlcmF0aW9uVG9rZW4pO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlQ2hhbmdlTWFuYWdlci51bnN1YnNjcmliZShwYXJ0LmFsaWFzLCBwYXJ0LnBlbmRpbmdPcGVyYXRpb25zLnBhdXNlLm9wZXJhdGlvblRva2VuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IG5ldyBBcnJheShwYXJ0LmVsZW1lbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIC8vIDIuIFBlcmZvcm0gdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnQuZWxlbWVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXNbaV0gPSB0aGlzLmhhbmRsZUFuaW1hdGlvbk92ZXJFbGVtZW50KHBhcnQuZWxlbWVudHNbaV0sIHBhcnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBhcnQucGVuZGluZ09wZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnQucGVuZGluZ09wZXJhdGlvbnMucGF1c2UuaXNQZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKFtwYXJ0LmFsaWFzXSk7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnBlbmRpbmdPcGVyYXRpb25zLnBhdXNlLmlzUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocGFydC5wZW5kaW5nT3BlcmF0aW9ucy5jYW5jZWwuaXNQZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbihbcGFydC5hbGlhc10pO1xyXG4gICAgICAgICAgICAgICAgcGFydC5wZW5kaW5nT3BlcmF0aW9ucy5jYW5jZWwuaXNQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEVsZW1lbnQgYW5pbWF0aW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSBhbmltYXRpb24gb3ZlciBhbiBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnQgdG8gYmUgYW5pbWF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gcGFydCBQYXJ0IHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnQgdG8gYmUgYW5pbWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSBhbmltYXRpb24gb3ZlciB0aGUgZWxlbWVudCBpcyBmaW5pc2hlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZUFuaW1hdGlvbk92ZXJFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwYXJ0OiBJQW5pbWF0aW9uRmxvd1BhcnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBzdHlsZXM6IHN0cmluZ1tdID0gcGFydC5zdHlsZXM7XHJcblxyXG4gICAgICAgIGlmIChzdHlsZXMpIHtcclxuICAgICAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0XFwncyByZXF1aXJlZCB0byBoYXZlIGF0IGxlYXN0IG9uZSBjbGFzcyB0byBnZW5lcmF0ZSBhbiBhbmltYXRpb24uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0XFwncyByZXF1aXJlZCB0byBoYXZlIGFuIGFycmF5IG9mIHN0eWxlcyB0byBnZW5lcmF0ZSBhbiBhbmltYXRpb24uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRnVuY3Rpb25zOiBBcnJheTwoKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpID0+IHZvaWQpPiA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBbmltYXRpb25JbmRleDogbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbkFuaW1hdGlvbkNhbmNlbCA9IGZ1bmN0aW9uKGFyZ3M6IElBbmltYXRpb25DYW5jZWxFdmVudEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN1bWUgdGhlIGFuaW1hdGlvbiBpZiBpdCBpcyBwYXVzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgb25BbmltYXRpb25QbGF5U3RhdGVDaGFuZ2Uoe2FsaWFzZXM6IGFyZ3MuYWxpYXNlcywgdmFsdWU6IEFuaW1hdGlvblBsYXlTdGF0ZVZhbHVlLnJ1bm5pbmd9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENBUk9VU0VMX1NUWUxFUy5DTEVBUl9BTklNQVRJT04pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBjdXJyZW50QW5pbWF0aW9uSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHN0eWxlc1tjdXJyZW50QW5pbWF0aW9uSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudW5yZWdpc3RlckFuaW1hdGlvbkxpc3RlbmVyKGVsZW1lbnQsIGFuaW1hdGlvbkZ1bmN0aW9uc1tjdXJyZW50QW5pbWF0aW9uSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0FST1VTRUxfU1RZTEVTLkNMRUFSX0FOSU1BVElPTik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYW5pbWF0aW9uQ2FuY2VsTWFuYWdlci51bnN1YnNjcmliZShwYXJ0LmFsaWFzLCBjYW5jZWxUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hbmltYXRpb25TdGF0ZUNoYW5nZU1hbmFnZXIudW5zdWJzY3JpYmUocGFydC5hbGlhcywgcGxheVN0YXRlQ2hhbmdldG9rZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFRva2VuID0gdGhhdC5hbmltYXRpb25DYW5jZWxNYW5hZ2VyLnN1YnNjcmliZShwYXJ0LmFsaWFzLCBvbkFuaW1hdGlvbkNhbmNlbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb25BbmltYXRpb25QbGF5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbihhcmdzOiBJQW5pbWF0aW9uU3RhdGVDaGFuZ2VFdmVudEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQW5pbWF0aW9uUGxheVN0YXRlVmFsdWUucGF1c2VkID09PSBhcmdzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0FST1VTRUxfU1RZTEVTLkFOSU1BVElPTl9QQVVTRUQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0FST1VTRUxfU1RZTEVTLkFOSU1BVElPTl9QQVVTRUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBbmltYXRpb25QbGF5U3RhdGVWYWx1ZS5ydW5uaW5nID09PSBhcmdzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDQVJPVVNFTF9TVFlMRVMuQU5JTUFUSU9OX1BBVVNFRCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDQVJPVVNFTF9TVFlMRVMuQU5JTUFUSU9OX1BBVVNFRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXlTdGF0ZUNoYW5nZXRva2VuID1cclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFuaW1hdGlvblN0YXRlQ2hhbmdlTWFuYWdlci5zdWJzY3JpYmUocGFydC5hbGlhcywgb25BbmltYXRpb25QbGF5U3RhdGVDaGFuZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3R5bGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShzdHlsZXNbaW5kZXggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnVucmVnaXN0ZXJBbmltYXRpb25MaXN0ZW5lcihlbGVtZW50LCBhbmltYXRpb25GdW5jdGlvbnNbaW5kZXggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJlZ2lzdGVyQW5pbWF0aW9uTGlzdGVuZXIoZWxlbWVudCwgYW5pbWF0aW9uRnVuY3Rpb25zW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoc3R5bGVzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9IChpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjbGVhciBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24oZXZlbnQ6IFRyYW5zaXRpb25FdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDQVJPVVNFTF9TVFlMRVMuQ0xFQVJfQU5JTUFUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoc3R5bGVzW3N0eWxlcy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENBUk9VU0VMX1NUWUxFUy5DTEVBUl9BTklNQVRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudW5yZWdpc3RlckFuaW1hdGlvbkxpc3RlbmVyKGVsZW1lbnQsIGFuaW1hdGlvbkZ1bmN0aW9uc1thbmltYXRpb25GdW5jdGlvbnMubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb25JbmRleCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hbmltYXRpb25DYW5jZWxNYW5hZ2VyLnVuc3Vic2NyaWJlKHBhcnQuYWxpYXMsIGNhbmNlbFRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFuaW1hdGlvblN0YXRlQ2hhbmdlTWFuYWdlci51bnN1YnNjcmliZShwYXJ0LmFsaWFzLCBwbGF5U3RhdGVDaGFuZ2V0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhhdC5yZWdpc3RlckFuaW1hdGlvbkxpc3RlbmVyKGVsZW1lbnQsIGFuaW1hdGlvbkZ1bmN0aW9uc1swXSk7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoc3R5bGVzWzBdKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb25JbmRleCA9IDA7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSBlbmQgb2YgYSB0cmFuc2l0aW9uIG92ZXIgYW4gZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgd2hvc2UgZXZlbnQgd2lsbCBiZSBoYW5kbGVkLlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIEV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlZ2lzdGVyQW5pbWF0aW9uTGlzdGVuZXIoZWxlbWVudDogSFRNTEVsZW1lbnQsIGxpc3RlbmVyOiAoZWxlbWVudDogVHJhbnNpdGlvbkV2ZW50KSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRBbmltYXRpb25FbmQnLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgYW4gZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBsaXN0IG9mIGxpc3RlbmVycyBvZiBhbiBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUYXJnZXQgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBMaXN0ZW5lciB0byBiZSB1bnN1YnNjcmliZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdW5yZWdpc3RlckFuaW1hdGlvbkxpc3RlbmVyKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBsaXN0ZW5lcjogKGVsZW1lbnQ6IFRyYW5zaXRpb25FdmVudCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgbGlzdGVuZXIpO1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0QW5pbWF0aW9uRW5kJywgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG59XHJcbiIsImV4cG9ydCBjb25zdCBBTklNQVRJT05fT1BFUkFUSU9OX0VWRU5UUyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIHRoZSBjYW5jZWxhdGlvbiBvZiB0aGUgY3VycmVudCBhbmltYXRpb24uXHJcbiAgICAgKi9cclxuICAgIEFOSU1BVElPTl9DQU5DRUw6ICdhbmltLmNhbmNlbCcsXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGFuaW1hdGlvbiBwbGF5IHN0YXRlIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBBTklNQVRJT05fU1RBVEVfQ0hBTkdFOiAnYW5pbS5zdGF0ZS5jaGFuZ2UnLFxyXG59O1xyXG4iLCIvKipcclxuICogUmVwcmVzZW50cyB0aGUgcGxheSBzdGF0ZSBvZiBhbiBhbmltYXRpb25cclxuICovXHJcbmV4cG9ydCBlbnVtIEFuaW1hdGlvblBsYXlTdGF0ZVZhbHVlIHtcclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgdG8gcmVwcmVzZW50IGEgcGF1c2VkIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgcGF1c2VkLFxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZSB0byByZXByZXNlbnQgYSBydW5uaW5nIHN0YXR1cy5cclxuICAgICAqL1xyXG4gICAgcnVubmluZyxcclxufVxyXG4iLCIvKipcbiAqIENhcm91c2VsIGNsYXNzZXMgdXNlZCBmb3IgbXVsdGlwbGUgcHVycG9zZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBDQVJPVVNFTF9TVFlMRVMgPSB7XG4gICAgQU5JTUFUSU9OX1BBVVNFRDogJ3NvcmEtYW5pbWF0aW9uLXBhdXNlZCcsXG4gICAgQ0FST1VTRUw6ICdzb3JhLWNhcm91c2VsJyxcbiAgICBDTEVBUl9BTklNQVRJT046ICdzb3JhLWNsZWFyLWFuaW1hdGlvbnMnLFxuICAgIFNMSURFOiAnc29yYS1zbGlkZScsXG4gICAgV1JBUFBFUjogJ3NvcmEtd3JhcHBlcicsXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBnZW5lcmljIGNhcm91c2VsLlxuICpcbiAqIDEuIEFueSBjYXJvdXNlbCBoYXMgZWxlbWVudHMuXG4gKiAyLiBBbnkgY2Fyb3VzZWwgaGFzIGEgdG9wb2xvZ3kuXG4gKiAzLiBBbnkgY2Fyb3VzZWwgaGFzIHRyYW5zaXRpb25zLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2Fyb3VzZWxCYXNlIHtcbiAgICAvKipcbiAgICAgKiBDYXJvdXNlbCBoYW5kbGVyLlxuICAgICAqIDMuIEFueSBjYXJvdXNlbCBoYXMgdHJhbnNpdGlvbnMuXG4gICAgICogQHBhcmFtIGFjdGlvbiBhY3Rpb24gdG8gYmUgaGFuZGxlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGhhbmRsZShhY3Rpb246IHN0cmluZywgb3B0aW9uczoge1trZXk6IHN0cmluZ106IGFueX0pOiB2b2lkO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IFNpbmdsZUFuaW1hdGlvbkVuZ2luZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9hbmltYXRpb24tZW5naW5lJztcbmltcG9ydCB7IElBbmltYXRpb25GbG93UGFydCB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9hbmltYXRpb24tZmxvdy1wYXJ0JztcbmltcG9ydCB7IEFuaW1hdGlvblBsYXlTdGF0ZVZhbHVlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2FuaW1hdGlvbi1wbGF5LXN0YXRlJztcbmltcG9ydCB7IENhbmNlbGFibGVDb2xsZWN0aW9uQ2hhbmdlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY29sbGVjdGlvbi9jYW5jZWxhYmxlLWNvbGxlY3Rpb24tY2hhbmdlLWFyZ3MnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvbGxlY3Rpb24vY29sbGVjdGlvbi1jaGFuZ2UtYXJncyc7XG5pbXBvcnQgeyBDT0xMRUNUSU9OX01BTkFHRVJfRVZFTlRTIH0gZnJvbSAnLi4vLi4vY29sbGVjdGlvbi9jb2xsZWN0aW9uLW1hbmFnZXInO1xuaW1wb3J0IHsgSHRtbENoaWxkcmVuTWFuYWdlciB9IGZyb20gJy4uLy4uL2NvbGxlY3Rpb24vaHRtbC1jaGlsZHJlbi1tYW5hZ2VyJztcbmltcG9ydCB7IElUYXNrRmxvdyB9IGZyb20gJy4uLy4uL3Rhc2svZmxvdy90YXNrLWZsb3cnO1xuaW1wb3J0IHtcbiAgICBDQVJPVVNFTF9TVFlMRVMsXG4gICAgQ2Fyb3VzZWxCYXNlLFxufSBmcm9tICcuLi9jYXJvdXNlbC1iYXNlJztcbmltcG9ydCB7XG4gICAgSVNpbmdsZVNsaWRlQ2Fyb3VzZWxBbmltYXRpb25FbmRFdmVudEFyZ3MsXG4gICAgSVNpbmdsZVNsaWRlQ2Fyb3VzZWxBbmltYXRpb25QbGF5U3RhdGVDaGFuZ2VFdmVudEFyZ3MsXG4gICAgSVNpbmdsZVNsaWRlQ2Fyb3VzZWxBbmltYXRpb25TdGFydEV2ZW50QXJncyxcbiAgICBJU2luZ2xlU2xpZGVDYXJvdXNlbENhbmNlbEFuaW1hdGlvbkV2ZW50QXJncyxcbn0gZnJvbSAnLi9hbmltYXRpb24tZXZlbnRzJztcbmltcG9ydCB7IElDYXJvdXNlbEFuaW1hdGlvbkNoaWxkcmVuU3R5bGVzIH0gZnJvbSAnLi9jYXJvdXNlbC1hbmltYXRpb24nO1xuaW1wb3J0IHsgSVNpbmdsZVNsaWRlQ2Fyb3VzZWxDcmVhdGVXYWl0UHJvbWlzZU9wdGlvbnMgfSBmcm9tICcuL2NyZWF0ZS13YWl0LXByb21pc2Utb3B0aW9ucyc7XG5pbXBvcnQgeyBJU2luZ2xlU2xpZGVDYXJvdXNlbENyZWF0aW9uT3B0aW9ucyB9IGZyb20gJy4vY3JlYXRpb24tb3B0aW9ucyc7XG5pbXBvcnQgeyBJU2luZ2xlU2xpZGVDYXJvdXNlbEdvVG9BbmltYXRpb25TdGF0dXMgfSBmcm9tICcuL2dvLXRvLWFuaW1hdGlvbi1zdGF0dXMnO1xuaW1wb3J0IHsgSVNpbmdsZVNsaWRlQ2Fyb3VzZWxHb3RvT3B0aW9ucyB9IGZyb20gJy4vZ28tdG8tb3B0aW9ucyc7XG5cbi8qICNyZWdpb24gQ29uc3RhbnRzICovXG5cbi8qKlxuICogQWN0aW9ucyBhdmFpYWJsZSBmb3IgdGhlIFNpbmdsZVNsaWRlQ2Fyb3VzZWwuXG4gKi9cbmV4cG9ydCBjb25zdCBTSU5HTEVfU0xJREVfQ0FST1VTRUxfQUNUSU9OUyA9IHtcbiAgICBHT19UTzogJ3RvJyxcbiAgICBHT19UT19ORVhUOiAnbmV4dCcsXG4gICAgR09fVE9fUFJFVklPVVM6ICdwcmV2Jyxcbn07XG5cbi8qKlxuICogRXZlbnRzIGRpcmVjdGx5IGhhbmRsZWQgYnkgdGhlIGNhcm91c2VsLlxuICovXG5leHBvcnQgY29uc3QgU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUyA9IHtcbiAgICBPTl9BTklNQVRJT05fRU5EOiAnY2FyLmFuaW0ub3V0JyxcbiAgICBPTl9BTklNQVRJT05fUExBWV9TVEFURV9DSEFOR0U6ICdjYXIuYW5pbS5zdGF0ZS5jaCcsXG4gICAgT05fQU5JTUFUSU9OX1NUQVJUOiAnY2FyLmFuaW0uaW4nLFxuICAgIE9OX0NBTkNFTF9BTklNQVRJT046ICdjYXIuYW5pbS5jYW5jZWwnLFxufTtcblxuZXhwb3J0IGNvbnN0IFNJTkdMRV9TTElERV9DQVJPVVNFTF9QQVJUU19BTElBU0VTID0ge1xuICAgIEVOVEVSOiAnZW50ZXItcGFydCcsXG4gICAgTEVBVkU6ICdsZWF2ZS1wYXJ0Jyxcbn07XG5cbi8qKlxuICogQ2Fyb3VzZWwgY2xhc3NlcyB1c2VkIGZvciBtdWx0aXBsZSBwdXJwb3Nlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFNJTkdMRV9TTElERV9DQVJPVVNFTF9TVFlMRVMgPSB7XG4gICAgLyoqXG4gICAgICogU3R5bGUgdG8gYXBwbHkgdG8gaGlkZGVuIHNsaWRlcy5cbiAgICAgKi9cbiAgICBTTElERV9ISURERU46ICdzb3JhLWhpZGRlbicsXG4gICAgLyoqXG4gICAgICogU3R5bGUgdG8gYXBwbHkgdG8gYWNoaWV2ZSBwb3NpdGlvbjogcmVsYXRpdmUuXG4gICAgICovXG4gICAgU09SQV9SRUxBVElWRTogJ3NvcmEtcmVsYXRpdmUnLFxufTtcblxuLyogI2VuZHJlZ2lvbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjYXJvdXNlbCB3aXRoIGEgc2luZ2xlIGFjdGl2ZSBzbGlkZSBhdCBhIHRpbWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW5nbGVTbGlkZUNhcm91c2VsIGV4dGVuZHMgQ2Fyb3VzZWxCYXNlIHtcblxuICAgIC8vI3JlZ2lvbiBBdHRyaWJ1dGVzXG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmUgaW5kZXggb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBjYXJvdXNlbC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWN0aXZlSW5kZXg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYWN0aXZlIGFuaW1hdGlvblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjdXJyZW50QW5pbWF0aW9uOiBJU2luZ2xlU2xpZGVDYXJvdXNlbEdvdG9PcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogY29sbGVjdGlvbiBtYW5hZ2VyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGVsZW1lbnRzTWFuYWdlcjogSHRtbENoaWxkcmVuTWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIEVuZ2luZSBhbmltYXRpb24uXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGVuZ2luZUFuaW1hdGlvbjogU2luZ2xlQW5pbWF0aW9uRW5naW5lO1xuXG4gICAgLyoqXG4gICAgICogRmxhZyB0byBkZXRlcm1pbmUgaWYgdGhlIGNhcm91c2VsIGFuaW1hdGlvbiBpcyBwYXVzZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBhdXNlZDogYm9vbGVhbjtcblxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIEV2ZW50c1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlciBmb3IgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcblxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgICAqIEBwYXJhbSBlbGVtZW50IERPTSBlbGVtZW50IGFzc29jaWF0ZWQgdG8gdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgb3B0aW9uczogSVNpbmdsZVNsaWRlQ2Fyb3VzZWxDcmVhdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbGVtZW50IG11c3Qgbm90IGJlIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDQVJPVVNFTF9TVFlMRVMuQ0FST1VTRUwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYXJvdXNlbCBlbGVtZW50IG11c3QgY29udGFpbiB0aGUgY2xhc3MgXCInICsgQ0FST1VTRUxfU1RZTEVTLkNBUk9VU0VMICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc29yYVdyYXBwZXIgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ0FST1VTRUxfU1RZTEVTLldSQVBQRVIpO1xuXG4gICAgICAgIGlmIChzb3JhV3JhcHBlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbGVtZW50IGhhcyBubyBjaGlsZCB3aXRoIGNsYXNzIFxcJ3NvcmEtd3JhcHBlclxcJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuOiBIVE1MRWxlbWVudFtdID0gbmV3IEFycmF5KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3JhV3JhcHBlci5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHNvcmFXcmFwcGVyLmNoaWxkcmVuW2ldLmNsYXNzTGlzdC5jb250YWlucyhDQVJPVVNFTF9TVFlMRVMuU0xJREUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChzb3JhV3JhcHBlci5jaGlsZHJlbltpXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c01hbmFnZXIgPSBuZXcgSHRtbENoaWxkcmVuTWFuYWdlcihjaGlsZHJlbiwgdGhpcy5ldmVudEVtaXR0ZXIsIHNvcmFXcmFwcGVyIGFzIEhUTUxFbGVtZW50KTtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA8IDAgfHwgdGhpcy5hY3RpdmVJbmRleCA+PSB0aGlzLmVsZW1lbnRzTWFuYWdlci5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbnMuaW5kZXguIFRoZXJlIGlzIG5vIGVsZW1lbnQgd2l0aCBpbmRleCAnICsgb3B0aW9ucy5pbmRleCArICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5hY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLmNsYXNzTGlzdC5hZGQoU0lOR0xFX1NMSURFX0NBUk9VU0VMX1NUWUxFUy5TT1JBX1JFTEFUSVZFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uY2xhc3NMaXN0LmFkZChTSU5HTEVfU0xJREVfQ0FST1VTRUxfU1RZTEVTLlNMSURFX0hJRERFTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcblxuICAgICAgICAvLyBBZGQgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IG9uQmVmb3JlQ2hhbmdlID0gZnVuY3Rpb24oZXZlbnRBcmdzOiBDYW5jZWxhYmxlQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJnczxIVE1MRWxlbWVudD4pIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4TWFwID0gZXZlbnRBcmdzLmdldEluZGV4TWFwKCk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSBpbmRleE1hcFt0aGF0LmFjdGl2ZUluZGV4XSkge1xuICAgICAgICAgICAgICAgIGV2ZW50QXJncy5zZXRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uQWZ0ZXJDaGFuZ2UgPSBmdW5jdGlvbihldmVudEFyZ3M6IENvbGxlY3Rpb25DaGFuZ2VFdmVudEFyZ3M8SFRNTEVsZW1lbnQ+KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50QXJncy5nZXRQcmV2ZW50RGVmYXVsdCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBldmVudEFyZ3MuZ2V0SW5kZXhNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGF0LmFjdGl2ZUluZGV4ID0gaW5kZXhNYXBbdGhhdC5hY3RpdmVJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihDT0xMRUNUSU9OX01BTkFHRVJfRVZFTlRTLmNvbGxlY3Rpb25CZWZvcmVDaGFuZ2UsIG9uQmVmb3JlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihDT0xMRUNUSU9OX01BTkFHRVJfRVZFTlRTLmNvbGxlY3Rpb25BZnRlckNoYW5nZSwgb25BZnRlckNoYW5nZSk7XG5cbiAgICAgICAgdGhpcy5lbmdpbmVBbmltYXRpb24gPSBuZXcgU2luZ2xlQW5pbWF0aW9uRW5naW5lKCk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFB1YmxpY1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IG9mIHRoZSBjYXJvdXNlbC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgdG8gbGlzdGVuLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBMaXN0ZW5lciB0byBzdWJzY3JpYmUuXG4gICAgICovXG4gICAgcHVibGljIGFkZExpc3RlbmVyKGV2ZW50OiBzdHJpbmcgfCBzeW1ib2wsIGxpc3RlbmVyOiAoLi4uIGFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCB3YWl0cyBmb3IgYSB0aW1lLiBUaGUgYW1vdW50IG9mIHRpbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJU2luZ2xlU2xpZGVDYXJvdXNlbENyZWF0ZVdhaXRQcm9taXNlT3B0aW9ucy5cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlV2FpdFByb21pc2Uob3B0aW9uczogSVNpbmdsZVNsaWRlQ2Fyb3VzZWxDcmVhdGVXYWl0UHJvbWlzZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBsYXN0VGltZVJ1bjogbnVtYmVyO1xuICAgICAgICAgICAgdmFyIHRpbWVUb1dhaXQgPSBvcHRpb25zLm1pbGxpcztcblxuICAgICAgICAgICAgaWYgKHRoYXQucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgbGFzdFRpbWVSdW4gPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgd2FpdEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGltZVRvV2FpdCk7XG4gICAgICAgICAgICAgICAgbGFzdFRpbWVSdW4gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9uQ2FuY2VsQW5pbWF0aW9uOiAoKSA9PiB2b2lkID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RvcE9uQ2FuY2VsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb25DYW5jZWxBbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoYXQuYWRkTGlzdGVuZXIoU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUy5PTl9DQU5DRUxfQU5JTUFUSU9OLCBvbkNhbmNlbEFuaW1hdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9uUGxheVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24oYXJnczogSVNpbmdsZVNsaWRlQ2Fyb3VzZWxBbmltYXRpb25QbGF5U3RhdGVDaGFuZ2VFdmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoQW5pbWF0aW9uUGxheVN0YXRlVmFsdWUucGF1c2VkID09PSBhcmdzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhdXNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVUb1dhaXQgPSB0aW1lVG9XYWl0IC0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdFRpbWVSdW4pO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHdhaXRJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBbmltYXRpb25QbGF5U3RhdGVWYWx1ZS5ydW5uaW5nID09PSBhcmdzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3VtZVxuICAgICAgICAgICAgICAgICAgICBsYXN0VGltZVJ1biA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDwgdGltZVRvV2FpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUy5PTl9BTklNQVRJT05fUExBWV9TVEFURV9DSEFOR0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUGxheVN0YXRlQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gb25DYW5jZWxBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTkdMRV9TTElERV9DQVJPVVNFTF9FVkVOVFMuT05fQ0FOQ0VMX0FOSU1BVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsQW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aW1lVG9XYWl0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVMaXN0ZW5lcihTSU5HTEVfU0xJREVfQ0FST1VTRUxfRVZFTlRTLk9OX0FOSU1BVElPTl9QTEFZX1NUQVRFX0NIQU5HRSwgb25QbGF5U3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG9uQ2FuY2VsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBTSU5HTEVfU0xJREVfQ0FST1VTRUxfRVZFTlRTLk9OX0NBTkNFTF9BTklNQVRJT04sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbEFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGF0LmFkZExpc3RlbmVyKFNJTkdMRV9TTElERV9DQVJPVVNFTF9FVkVOVFMuT05fQU5JTUFUSU9OX1BMQVlfU1RBVEVfQ0hBTkdFLCBvblBsYXlTdGF0ZUNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgY2Fyb3VzZWwgdG8gY2hhbmdlIGl0cyBhY3RpdmUgc2xpZGUuIEFueSBhbmltYXRpb24gd2lsbCBiZSBjYW5jZWxlZCBpbiB0aGUgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gYWN0aXZlSW5kZXggSW5kZXggb2YgdGhlIG5ldyBhY3RpdmUgc2xpZGUgb2YgdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIHB1YmxpYyBmb3JjZUFjdGl2ZVNsaWRlKGFjdGl2ZUluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJU2luZ2xlU2xpZGVDYXJvdXNlbENhbmNlbEFuaW1hdGlvbkV2ZW50QXJncyA9IHsgYWN0aXZlSW5kZXg6IGFjdGl2ZUluZGV4IH07XG5cbiAgICAgICAgdGhpcy5lbmdpbmVBbmltYXRpb24uY2FuY2VsQW5pbWF0aW9uKG51bGwpO1xuICAgICAgICAvLyBUaGUgY2FsbCBvdmVyIGNhbmNlbEFuaW1hdGlvbiB3aWxsIHJlc3VtZSBhbnkgcGF1c2VkIGFuaW1hdGlvbi5cbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgICAgICB0aGlzLnJlc2V0Q2Fyb3VzZWxTdHJ1Y3R1cmUoYWN0aXZlSW5kZXgpO1xuXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUy5PTl9DQU5DRUxfQU5JTUFUSU9OLCBldmVudEFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgdGhlIGFjdGl2ZSBzbGlkZSBvZiB0aGUgY2Fyb3VzZWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QWN0aXZlRWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzTWFuYWdlci5nZXRDb2xsZWN0aW9uKClbdGhpcy5hY3RpdmVJbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgYWN0aXZlIGluZGV4IGluIHRoZSBlbGVtZW50cyBhcnJheSBvZiB0aGUgY2Fyb3VzZWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QWN0aXZlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBtYW5hZ2VyIG9mIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyBDb2xsZWN0aW9uIG1hbmFnZXIgb2YgdGhlIHNsaWRlIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFbGVtZW50c01hbmFnZXIoKTogSHRtbENoaWxkcmVuTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjYXJvdXNlbCBoYXMgYW4gYWN0aXZlIGFuaW1hdGlvbiwgZXZlbiBpZiB0aGUgYW5pbWF0aW9uIGlzIFBhdXNlZC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjYXJvdXNlbCBoYXMgYW4gYWN0aXZlIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgaGFzQWN0aXZlQW5pbWF0aW9uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gbnVsbCAhPSB0aGlzLmN1cnJlbnRBbmltYXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZShhY3Rpb246IHN0cmluZywgb3B0aW9uczoge1trZXk6IHN0cmluZ106IGFueX0pOiBJU2luZ2xlU2xpZGVDYXJvdXNlbEdvVG9BbmltYXRpb25TdGF0dXMge1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBTSU5HTEVfU0xJREVfQ0FST1VTRUxfQUNUSU9OUy5HT19UTzpcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zLmluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9ucyBmb3IgXFwnJyArIFNJTkdMRV9TTElERV9DQVJPVVNFTF9BQ1RJT05TLkdPX1RPICsgJ1xcJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlR29UbyhvcHRpb25zIGFzIElTaW5nbGVTbGlkZUNhcm91c2VsR290b09wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBTSU5HTEVfU0xJREVfQ0FST1VTRUxfQUNUSU9OUy5HT19UT19ORVhUOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSAodGhpcy5hY3RpdmVJbmRleCArIDEpICUgdGhpcy5lbGVtZW50c01hbmFnZXIuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlKFNJTkdMRV9TTElERV9DQVJPVVNFTF9BQ1RJT05TLkdPX1RPLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgU0lOR0xFX1NMSURFX0NBUk9VU0VMX0FDVElPTlMuR09fVE9fUFJFVklPVVM6XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudHNMZW5ndGggPSB0aGlzLmVsZW1lbnRzTWFuYWdlci5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmluZGV4ID0gKCh0aGlzLmFjdGl2ZUluZGV4IC0gMSkgJSBlbGVtZW50c0xlbmd0aCArIGVsZW1lbnRzTGVuZ3RoKSAlIGVsZW1lbnRzTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZShTSU5HTEVfU0xJREVfQ0FST1VTRUxfQUNUSU9OUy5HT19UTywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNhcm91c2VsIGFuaW1hdGlvbiBpcyBwYXVzZWQuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY2Fyb3VzZWwgaXMgcGF1c2VkIGFuZCBmYWxzZSBpbiBhbnkgb3RoZXIgY2FzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIGFuaW1hdGlvbnMgY3VycmVudGx5IGhhbmRsZWQgYnkgdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIHB1YmxpYyBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmVBbmltYXRpb24ucGF1c2UobnVsbCk7XG4gICAgICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFxuICAgICAgICAgICAgICAgIFNJTkdMRV9TTElERV9DQVJPVVNFTF9FVkVOVFMuT05fQU5JTUFUSU9OX1BMQVlfU1RBVEVfQ0hBTkdFLFxuICAgICAgICAgICAgICAgIHsgdmFsdWUgOiBBbmltYXRpb25QbGF5U3RhdGVWYWx1ZS5wYXVzZWQgfSBhcyBJU2luZ2xlU2xpZGVDYXJvdXNlbEFuaW1hdGlvblBsYXlTdGF0ZUNoYW5nZUV2ZW50QXJncyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYSBsaXN0ZW5lciB0byBhbiBldmVudCBvZiB0aGUgY2Fyb3VzZWwuXG4gICAgICogQHBhcmFtIGV2ZW50IEV2ZW50IGFzc29jaWF0ZWQuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIExpc3RlbmVyIHRvIHVuc3Vic2NyaWJlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihldmVudDogc3RyaW5nIHwgc3ltYm9sLCBsaXN0ZW5lcjogKC4uLiBhcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgdGhlIGFuaW1hdGlvbnMgY3VycmVudGx5IGhhbmRsZWQgYnkgdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmVBbmltYXRpb24ucmVzdW1lKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXG4gICAgICAgICAgICAgICAgU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUy5PTl9BTklNQVRJT05fUExBWV9TVEFURV9DSEFOR0UsXG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogQW5pbWF0aW9uUGxheVN0YXRlVmFsdWUucnVubmluZyB9IGFzIElTaW5nbGVTbGlkZUNhcm91c2VsQW5pbWF0aW9uUGxheVN0YXRlQ2hhbmdlRXZlbnRBcmdzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIFByb3RlY3RlZFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbmltYXRpb24gZmxvdyBiYXNlZCBvbiBhbmltYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbnRlckVsZW1lbnQgRWxlbWVudCB0byBhcHBseSB0aGUgZW50ZXIgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSBsZWF2ZUVsZW1lbnQgRWxlbWVudCB0byBhcHBseSB0aGUgbGVhdmUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuaW1hdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW5pbWF0aW9uIGZsb3cgZnJvbSB0aGUgYW5pbWF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlR29Ub0FuaW1hdGlvbkZsb3coXG4gICAgICAgIGVudGVyRWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgIGxlYXZlRWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgIG9wdGlvbnM6IElTaW5nbGVTbGlkZUNhcm91c2VsR290b09wdGlvbnMsXG4gICAgKTogSVRhc2tGbG93PElBbmltYXRpb25GbG93UGFydD4ge1xuICAgICAgICBjb25zdCBpbm5lclBhcnRzOiBJQW5pbWF0aW9uRmxvd1BhcnRbXSA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhbGlhczogU0lOR0xFX1NMSURFX0NBUk9VU0VMX1BBUlRTX0FMSUFTRVMuRU5URVIsXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IFsgZW50ZXJFbGVtZW50IF0sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBvcHRpb25zLmVudGVyQW5pbWF0aW9uLnNsaWRlU3R5bGVzLFxuICAgICAgICAgICAgICAgIHdoZW46IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFsaWFzOiBTSU5HTEVfU0xJREVfQ0FST1VTRUxfUEFSVFNfQUxJQVNFUy5MRUFWRSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogWyBsZWF2ZUVsZW1lbnQgXSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IG9wdGlvbnMubGVhdmVBbmltYXRpb24uc2xpZGVTdHlsZXMsXG4gICAgICAgICAgICAgICAgd2hlbjogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgZ2VuZXJhdGVDaGlsZHJlblBhcnRzID0gZnVuY3Rpb24oXG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICAgICAgICAgIGNoaWxkcmVuU3R5bGVzOiBJQ2Fyb3VzZWxBbmltYXRpb25DaGlsZHJlblN0eWxlc1tdLFxuICAgICAgICAgICAgYWxpYXNCYXNlOiBzdHJpbmcsXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlblN0eWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpbm5lclBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IGFsaWFzQmFzZSArIGkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBmdW5jdGlvbigpOiBIVE1MRWxlbWVudFtdIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50czogSFRNTEVsZW1lbnRbXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbk9iamVjdDogSUNhcm91c2VsQW5pbWF0aW9uQ2hpbGRyZW5TdHlsZXMgPSBjaGlsZHJlblN0eWxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbkVsZW1lbnRzID0gcGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGFuaW1hdGlvbk9iamVjdC5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkcmVuRWxlbWVudCBvZiBjaGlsZHJlbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY2hpbGRyZW5FbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBjaGlsZHJlblN0eWxlc1tpXS5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZ2VuZXJhdGVDaGlsZHJlblBhcnRzKFxuICAgICAgICAgICAgZW50ZXJFbGVtZW50LFxuICAgICAgICAgICAgb3B0aW9ucy5lbnRlckFuaW1hdGlvbi5jaGlsZHJlblN0eWxlcyxcbiAgICAgICAgICAgIFNJTkdMRV9TTElERV9DQVJPVVNFTF9QQVJUU19BTElBU0VTLkVOVEVSLFxuICAgICAgICApO1xuICAgICAgICBnZW5lcmF0ZUNoaWxkcmVuUGFydHMoXG4gICAgICAgICAgICBsZWF2ZUVsZW1lbnQsXG4gICAgICAgICAgICBvcHRpb25zLmxlYXZlQW5pbWF0aW9uLmNoaWxkcmVuU3R5bGVzLFxuICAgICAgICAgICAgU0lOR0xFX1NMSURFX0NBUk9VU0VMX1BBUlRTX0FMSUFTRVMuTEVBVkUsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaW5uZXJQYXJ0c01hcDogeyBba2V5OiBzdHJpbmddOiBJQW5pbWF0aW9uRmxvd1BhcnQgfSA9IHsgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyUGFydCBvZiBpbm5lclBhcnRzKSB7XG4gICAgICAgICAgICBpbm5lclBhcnRzTWFwW2lubmVyUGFydC5hbGlhc10gPSBpbm5lclBhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uRmxvdzogSVRhc2tGbG93PElBbmltYXRpb25GbG93UGFydD4gPSB7XG4gICAgICAgICAgICBwYXJ0czogaW5uZXJQYXJ0cyxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uRmxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGNhcm91c2VsIHN0cnVjdHVyZS4gU2V0cyBhIG5ldyBhY3RpdmUgZWxlbWVudCBmb3IgdGhlIGNhcm91c2VsLlxuICAgICAqIEBwYXJhbSBhY3RpdmVJbmRleCBDdXJyZW50IGFjdGl2ZSBpbmRleC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVzZXRDYXJvdXNlbFN0cnVjdHVyZShhY3RpdmVJbmRleDogbnVtYmVyKSB7XG4gICAgICAgIC8vIFRoaXMgb3BlcmF0aW9uIGlzIGF0b21pYyBpbiBhIHNpbmdsZS10aHJlYWQgZW52aXJvbm1lbnQsIHNvIHdlIGNhbiBzdG9yZSB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuZWxlbWVudHNNYW5hZ2VyLmdldENvbGxlY3Rpb24oKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB3aGlsZSAoY29sbGVjdGlvbltpXS5jbGFzc0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baV0uY2xhc3NMaXN0LnJlbW92ZShjb2xsZWN0aW9uW2ldLmNsYXNzTGlzdC5pdGVtKDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sbGVjdGlvbltpXS5jbGFzc0xpc3QuYWRkKENBUk9VU0VMX1NUWUxFUy5TTElERSk7XG5cbiAgICAgICAgICAgIGlmIChpID09PSBhY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baV0uY2xhc3NMaXN0LmFkZChTSU5HTEVfU0xJREVfQ0FST1VTRUxfU1RZTEVTLlNPUkFfUkVMQVRJVkUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2ldLmNsYXNzTGlzdC5hZGQoU0lOR0xFX1NMSURFX0NBUk9VU0VMX1NUWUxFUy5TTElERV9ISURERU4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICAvLyNyZWdpb24gUHJpdmF0ZVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgR29UbyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB3aXRoIHRoZSBpbmRleCBhbmQgdGhlIGN1c3RvbSBhbmltYXRpb24gdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUdvVG8ob3B0aW9uczogSVNpbmdsZVNsaWRlQ2Fyb3VzZWxHb3RvT3B0aW9ucyk6IElTaW5nbGVTbGlkZUNhcm91c2VsR29Ub0FuaW1hdGlvblN0YXR1cyB7XG4gICAgICAgIGlmIChvcHRpb25zLmluZGV4IDwgMCB8fCBvcHRpb25zLmluZGV4ID49IHRoaXMuZWxlbWVudHNNYW5hZ2VyLmdldExlbmd0aCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXguIFRoZXJlIGlzIG5vIGVsZW1lbnQgd2l0aCBpbmRleCAnICsgb3B0aW9ucy5pbmRleCArICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5pbmRleCA9PT0gdGhpcy5hY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4LiBJdFxcJ3Mgbm90IGFsbG93ZWQgdG8gZ28gdG8gdGhlIGN1cnJlbnQgYWN0aXZlIHNsaWRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgPT0gdGhpcy5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdJdFxcJ3Mgbm90IGFsbG93ZWQgdG8gc3RhcnQgYW4gYW5pbWF0aW9uIHdoaWxlIGFuIGV4aXN0aW5nIGFuaW1hdGlvbiBvdmVyIGFuIHNsaWRlIGVsZW1lbnQgaXMgYWN0aXZlJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRBY3RpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50c01hbmFnZXIuZ2V0Q29sbGVjdGlvbigpW3RoaXMuYWN0aXZlSW5kZXhdO1xuICAgICAgICB2YXIgbmV3QWN0aXZlSW5kZXg6IG51bWJlciA9IG9wdGlvbnMuaW5kZXg7XG5cbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChTSU5HTEVfU0xJREVfQ0FST1VTRUxfRVZFTlRTLk9OX0FOSU1BVElPTl9TVEFSVCwge1xuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfSBhcyBJU2luZ2xlU2xpZGVDYXJvdXNlbEFuaW1hdGlvblN0YXJ0RXZlbnRBcmdzKTtcblxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcblxuICAgICAgICBjb25zdCBvbkJlZm9yZUNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50QXJnczogQ2FuY2VsYWJsZUNvbGxlY3Rpb25DaGFuZ2VFdmVudEFyZ3M8SFRNTEVsZW1lbnQ+KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleE1hcCA9IGV2ZW50QXJncy5nZXRJbmRleE1hcCgpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gaW5kZXhNYXBbbmV3QWN0aXZlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRBcmdzLnNldFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb25BZnRlckNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50QXJnczogQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJnczxIVE1MRWxlbWVudD4pIHtcbiAgICAgICAgICAgIGlmICghZXZlbnRBcmdzLmdldFByZXZlbnREZWZhdWx0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleE1hcCA9IGV2ZW50QXJncy5nZXRJbmRleE1hcCgpO1xuICAgICAgICAgICAgICAgIG5ld0FjdGl2ZUluZGV4ID0gaW5kZXhNYXBbbmV3QWN0aXZlSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkTGlzdGVuZXIoQ09MTEVDVElPTl9NQU5BR0VSX0VWRU5UUy5jb2xsZWN0aW9uQmVmb3JlQ2hhbmdlLCBvbkJlZm9yZUNoYW5nZSk7XG4gICAgICAgIHRoaXMuYWRkTGlzdGVuZXIoQ09MTEVDVElPTl9NQU5BR0VSX0VWRU5UUy5jb2xsZWN0aW9uQWZ0ZXJDaGFuZ2UsIG9uQWZ0ZXJDaGFuZ2UpO1xuXG4gICAgICAgIGNvbnN0IG5ld0FjdGl2ZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzTWFuYWdlci5nZXRDb2xsZWN0aW9uKClbbmV3QWN0aXZlSW5kZXhdO1xuXG4gICAgICAgIG5ld0FjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShTSU5HTEVfU0xJREVfQ0FST1VTRUxfU1RZTEVTLlNMSURFX0hJRERFTik7XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgY2FuY2VsQW5pbWF0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhhdC5jdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhbmltYXRpb25GbG93ID0gdGhpcy5nZW5lcmF0ZUdvVG9BbmltYXRpb25GbG93KG5ld0FjdGl2ZUVsZW1lbnQsIG9sZEFjdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhbmltYXRpb25Qcm9taXNlczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSB0aGlzLmVuZ2luZUFuaW1hdGlvbi5oYW5kbGUoYW5pbWF0aW9uRmxvdyk7XG4gICAgICAgIGNvbnN0IEFOSU1BVElPTl9FTlRFUl9JTkRFWDogbnVtYmVyID0gMDtcbiAgICAgICAgY29uc3QgQU5JTUFUSU9OX0xFQVZFX0lOREVYOiBudW1iZXIgPSAxO1xuXG4gICAgICAgIGNvbnN0IGhpZGVMZWF2ZVNsaWRlQWZ0ZXJBbmltYXRpb25FbmRzID0gbmV3IFByb21pc2U8dm9pZD4oZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlc1tBTklNQVRJT05fTEVBVkVfSU5ERVhdLnRoZW4oZnVuY3Rpb24oYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKFNJTkdMRV9TTElERV9DQVJPVVNFTF9TVFlMRVMuU0xJREVfSElEREVOKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFNJTkdMRV9TTElERV9DQVJPVVNFTF9TVFlMRVMuU09SQV9SRUxBVElWRSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChTSU5HTEVfU0xJREVfQ0FST1VTRUxfU1RZTEVTLlNPUkFfUkVMQVRJVkUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKFNJTkdMRV9TTElERV9DQVJPVVNFTF9FVkVOVFMuT05fQ0FOQ0VMX0FOSU1BVElPTiwgY2FuY2VsQW5pbWF0aW9uSGFuZGxlcik7XG5cbiAgICAgICAgY29uc3Qgc29yYUhhbmRsZXJTdGF0dXM6IFByb21pc2U8dm9pZD4gPSBuZXcgUHJvbWlzZTx2b2lkPihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlc1tBTklNQVRJT05fRU5URVJfSU5ERVhdLFxuICAgICAgICAgICAgICAgIGhpZGVMZWF2ZVNsaWRlQWZ0ZXJBbmltYXRpb25FbmRzLFxuICAgICAgICAgICAgXSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWN0aXZlSW5kZXggPSBuZXdBY3RpdmVJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKENPTExFQ1RJT05fTUFOQUdFUl9FVkVOVFMuY29sbGVjdGlvbkJlZm9yZUNoYW5nZSwgb25CZWZvcmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlTGlzdGVuZXIoQ09MTEVDVElPTl9NQU5BR0VSX0VWRU5UUy5jb2xsZWN0aW9uQWZ0ZXJDaGFuZ2UsIG9uQWZ0ZXJDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlTGlzdGVuZXIoU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUy5PTl9DQU5DRUxfQU5JTUFUSU9OLCBjYW5jZWxBbmltYXRpb25IYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRFbWl0dGVyLmVtaXQoXG4gICAgICAgICAgICAgICAgICAgIFNJTkdMRV9TTElERV9DQVJPVVNFTF9FVkVOVFMuT05fQU5JTUFUSU9OX0VORCxcbiAgICAgICAgICAgICAgICAgICAge30gYXMgSVNpbmdsZVNsaWRlQ2Fyb3VzZWxBbmltYXRpb25FbmRFdmVudEFyZ3MsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlczogYW5pbWF0aW9uUHJvbWlzZXMsXG4gICAgICAgICAgICBwYXJ0RW5kRXZlbnRBY2Nlc3M6IHRoYXQuZW5naW5lQW5pbWF0aW9uLmdldFBhcnRFbmRMaXN0ZW5lckFjY2VzcygpLFxuICAgICAgICAgICAgcGFydFN0YXJ0RXZlbnRBY2Nlc3M6IHRoYXQuZW5naW5lQW5pbWF0aW9uLmdldFBhcnRTdGFydExpc3RlbmVyQWNjZXNzKCksXG4gICAgICAgICAgICBzb3JhSGFuZGxlclN0YXR1czogc29yYUhhbmRsZXJTdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJncyB9IGZyb20gJy4vY29sbGVjdGlvbi1jaGFuZ2UtYXJncyc7XHJcblxyXG5leHBvcnQgY2xhc3MgQ2FuY2VsYWJsZUNvbGxlY3Rpb25DaGFuZ2VFdmVudEFyZ3M8VD4gZXh0ZW5kcyBDb2xsZWN0aW9uQ2hhbmdlRXZlbnRBcmdzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBpbmRleE1hcCBJbmRleCBtYXAsIGZyb20gb2xkIGluZGV4ZXMgdG8gbmV3IGluZGV4ZXMuXHJcbiAgICAgKiBAcGFyYW0gbmV3RWxlbWVudHMgTmV3IEVsZW1lbnRzIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoaW5kZXhNYXA6IHtbb2xkSW5kZXg6IG51bWJlcl06IG51bWJlcn0sIG5ld0VsZW1lbnRzOiBUW10pIHtcclxuICAgICAgICBzdXBlcihpbmRleE1hcCwgbmV3RWxlbWVudHMsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHByZXZlbnQgZGVmYXVsdCBhY3Rpb24gZmxhZyB0byB0cnVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UHJldmVudERlZmF1bHQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIENvbGxlY3Rpb25DaGFuZ2VFdmVudEFyZ3M8VD4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgZnJvbSBvbGQgaW5kZXhlcyB0byBuZXcgaW5kZXhlc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW5kZXhNYXA6IHtbb2xkSW5kZXg6IG51bWJlcl06IG51bWJlcn07XHJcbiAgICAvKipcclxuICAgICAqIG5ldyBFbGVtZW50cyBhcnJheVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbmV3RWxlbWVudHM6IFRbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZsYWcgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gKHVwZGF0ZSB0aGUgY29sbGVjdGlvbilcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHByZXZlbnREZWZhdWx0OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBpbmRleE1hcCBJbmRleCBtYXAsIGZyb20gb2xkIGluZGV4ZXMgdG8gbmV3IGluZGV4ZXMuXHJcbiAgICAgKiBAcGFyYW0gbmV3RWxlbWVudHMgTmV3IEVsZW1lbnRzIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoaW5kZXhNYXA6IHtbb2xkSW5kZXg6IG51bWJlcl06IG51bWJlcn0sIG5ld0VsZW1lbnRzOiBUW10sIHByZXZlbnREZWZhdWx0OiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hcCA9IGluZGV4TWFwO1xyXG4gICAgICAgIHRoaXMubmV3RWxlbWVudHMgPSBuZXdFbGVtZW50cztcclxuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgY29weSBvZiB0aGUgaW5kZXggbWFwLlxyXG4gICAgICogVGhlIGluZGV4IG1hcCBrZXlzIGFyZSB0aGUgb2xkIGluZGV4ZXMgb2YgdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgKiBUaGUgaW5kZXggbWFwIHZhbHVlcyBhcmUgdGhlIG5ldyBpbmRleGVzIGZvciB0aGUgb2xkIG9uZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJbmRleE1hcCgpOiB7W29sZEluZGV4OiBudW1iZXJdOiBudW1iZXJ9IHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleE1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgY29weSBvZiB0aGUgY29sbGVjdGlvbiB0aGF0IGNvdWxkIGJlIHRoZSBuZXcgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE5ld0VsZW1lbnRzKCk6IHtbaW5kZXg6IG51bWJlcl06IFR9IHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5uZXdFbGVtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uIGZsYWcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcmV2ZW50RGVmYXVsdCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50RGVmYXVsdDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xyXG5pbXBvcnQgeyBDYW5jZWxhYmxlQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJncyB9IGZyb20gJy4vY2FuY2VsYWJsZS1jb2xsZWN0aW9uLWNoYW5nZS1hcmdzJztcclxuaW1wb3J0IHsgQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJncyB9IGZyb20gJy4vY29sbGVjdGlvbi1jaGFuZ2UtYXJncyc7XHJcblxyXG5leHBvcnQgY29uc3QgQ09MTEVDVElPTl9NQU5BR0VSX0VWRU5UUyA9IHtcclxuICAgIGNvbGxlY3Rpb25BZnRlckNoYW5nZTogJ2NvbGwuY2guYScsXHJcbiAgICBjb2xsZWN0aW9uQmVmb3JlQ2hhbmdlOiAnY29sbC5jaC5iJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0aW9uIG1hbmFnZXIuXHJcbiAqIEhhbmRsZXMgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zIGFuZCBlbWl0cyBldmVudHMgb24gbW9kaWZpY2F0aW9ucyBvZiB0aGUgbWFuYWdlZCBjb2xsZWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbGxlY3Rpb25NYW5hZ2VyPFQ+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3Rpb24gdG8gbWFuYWdlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjb2xsZWN0aW9uOiBUW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBlbWl0dGVyIHVzZWQgdG8gZW1pdCBldmVudHNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgY2xhc3MuXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvbiBDb2xsZWN0aW9uIHRvIG1hbmFnZS5cclxuICAgICAqIEBwYXJhbSBldmVudEVtaXR0ZXIgRXZlbnQgZW1pdHRlciB1c2VkIHRvIGVtaXQgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoY29sbGVjdGlvbjogVFtdLCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcikge1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XHJcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFB1YmxpY1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBlbGVtZW50cyBtYW5hZ2VkLlxyXG4gICAgICogVGhpcyBpcyB0aGUgcmVhbCBjb2xsZWN0aW9uIG1hbmFnZWQgYnkgdGhlIGluc3RhbmNlLlxyXG4gICAgICogT25seSByZWFkIG9wZXJhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZCBkaXJlY3RseSBpbiB0aGUgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbGxlY3Rpb24oKTogVFtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbGVuZ3RoIG9mIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgICogQHJldHVybnMgTGVuZ3RoIG9mIHRoZSBjb2xsZWN0aW9uIG1hbmFnZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRMZW5ndGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGF0IHRoZSBzZWxlY3RlZCBpbmRleGVzLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRzIENvbGxlY3Rpb24gb2YgaW5kZXgtZWxlbWVudCBwYWlycyByZXByZXNlbnRpbmcgdGhlIGVsZW1lbnRzIHRvIGJlIGluc2VydGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5zZXJ0RWxlbWVudHMoZWxlbWVudHM6IHtbaW5kZXg6IG51bWJlcl06IFR9KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEluc2VydEVsZW1lbnRzKGVsZW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgb2YgdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhlcyBJbmRleGVzIG9mIHRoZSBjb2xsZWN0aW9uIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVFbGVtZW50cyhpbmRleGVzOiBudW1iZXJbXSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZW1vdmVFbGVtZW50cyhpbmRleGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGF0IHRoZSBzZWxlY3RlZCBpbmRleGVzLlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRzIENvbGxlY3Rpb24gb2YgaW5kZXgtZWxlbWVudCBwYWlycyByZXByZXNlbnRpbmcgdGhlIGVsZW1lbnRzIHRvIGJlIGluc2VydGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW50ZXJuYWxJbnNlcnRFbGVtZW50cyhlbGVtZW50czoge1tpbmRleDogbnVtYmVyXTogVH0pOiB2b2lkIHtcclxuICAgICAgICB2YXIga2V5czogbnVtYmVyW10gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1JbmRleCBpbiBlbGVtZW50cykge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudHMuaGFzT3duUHJvcGVydHkoZWxlbUluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyRWxlbUluZGV4ID0gTnVtYmVyKGVsZW1JbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyRWxlbUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluZGV4IHBhcmFtIHNob3VsZCBiZSBncmVhdGVyIG9yIGVxdWFscyB6ZXJvLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJFbGVtSW5kZXggPiB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGluZGV4IHBhcmFtIHNob3VsZCBiZSBsZXNzIG9yIGVxdWFscyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHRoZSBjb2xsZWN0aW9uLicsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChudW1iZXJFbGVtSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrZXlzID0ga2V5cy5zb3J0KGZ1bmN0aW9uKG51bWJlcjEsIG51bWJlcjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjEgLSBudW1iZXIyO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoMCA9PT0ga2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmV3RWxlbWVudHM6IFRbXSA9IG5ldyBBcnJheSh0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoICsga2V5cy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4TWFwOiB7W29sZEluZGV4OiBudW1iZXJdOiBudW1iZXJ9ID0ge307XHJcblxyXG4gICAgICAgIGlmICgxID09PSBrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGtleXNbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzW2ldID0gdGhpcy5jb2xsZWN0aW9uW2ldO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuZXdFbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IG5ld0VsZW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFbGVtZW50c1tpXSA9IHRoaXMuY29sbGVjdGlvbltpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpbmRleE1hcFtpIC0gMV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzWzBdOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG5ld0VsZW1lbnRzW2ldID0gdGhpcy5jb2xsZWN0aW9uW2ldO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuZXdFbGVtZW50c1trZXlzWzBdXSA9IGVsZW1lbnRzW2tleXNbMF1dO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFByZXZpb3VzID0ga2V5c1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaW5kZXhQcmV2aW91cyArIDE7IGogPCBpbmRleDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudHNbal0gPSB0aGlzLmNvbGxlY3Rpb25baiAtIGldO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwW2ogLSBpXSA9IGo7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3RWxlbWVudHNbaW5kZXhdID0gZWxlbWVudHNbaW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdICsgMTsgaSA8IG5ld0VsZW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFbGVtZW50c1tpXSA9IHRoaXMuY29sbGVjdGlvbltpIC0ga2V5cy5sZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaSAtIGtleXMubGVuZ3RoXSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxUcnlUb0NoYW5nZUNvbGxlY3Rpb24oaW5kZXhNYXAsIG5ld0VsZW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgb2YgdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhlcyBJbmRleGVzIG9mIHRoZSBjb2xsZWN0aW9uIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbnRlcm5hbFJlbW92ZUVsZW1lbnRzKGluZGV4ZXM6IG51bWJlcltdKTogdm9pZCB7XHJcbiAgICAgICAgLy8gU29ydCBpbmRleGVzLlxyXG4gICAgICAgIGluZGV4ZXMgPSBpbmRleGVzLnNvcnQoZnVuY3Rpb24obnVtYmVyMSwgbnVtYmVyMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyMSAtIG51bWJlcjI7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGluZGV4TWFwOiB7W29sZEluZGV4OiBudW1iZXJdOiBudW1iZXJ9ID0ge307XHJcbiAgICAgICAgY29uc3QgbmV3RWxlbWVudHM6IFRbXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sbGVjdGlvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXhlc1tjb3VudGVyXSkge1xyXG4gICAgICAgICAgICAgICAgKytjb3VudGVyO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3RWxlbWVudHNbaSAtIGNvdW50ZXJdID0gdGhpcy5jb2xsZWN0aW9uW2ldO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBpIC0gY291bnRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbFRyeVRvQ2hhbmdlQ29sbGVjdGlvbihpbmRleE1hcCwgbmV3RWxlbWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wcyB0byBjaGFuZ2UgdGhlIGNvbGxlY3Rpb24gbWFuYWdlZCBieSB0aGlzIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIGluZGV4TWFwIE1hcCBmcm9tIG9sZCBpbmRleGVzIHRvIG5ldyBpbmRleGVzLlxyXG4gICAgICogQHBhcmFtIG5ld0VsZW1lbnRzIE5ldyBlbGVtZW50cyB0byBtYW5hZ2UgaWYgdGhlIGNoYW5nZSBpcyBub3QgcHJldmVudGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW50ZXJuYWxUcnlUb0NoYW5nZUNvbGxlY3Rpb24oXHJcbiAgICAgICAgaW5kZXhNYXA6IHtbb2xkSW5kZXg6IG51bWJlcl06IG51bWJlcn0gPSB7fSxcclxuICAgICAgICBuZXdFbGVtZW50czogVFtdLFxyXG4gICAgKTogQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJnczxUPiB7XHJcbiAgICAgICAgY29uc3QgY2FuY2VsYWJsZUNoYW5nZUV2ZW50QXJncyA9IG5ldyBDYW5jZWxhYmxlQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJncyhpbmRleE1hcCwgbmV3RWxlbWVudHMpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoQ09MTEVDVElPTl9NQU5BR0VSX0VWRU5UUy5jb2xsZWN0aW9uQmVmb3JlQ2hhbmdlLCBjYW5jZWxhYmxlQ2hhbmdlRXZlbnRBcmdzKTtcclxuXHJcbiAgICAgICAgaWYgKCFjYW5jZWxhYmxlQ2hhbmdlRXZlbnRBcmdzLmdldFByZXZlbnREZWZhdWx0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbmV3RWxlbWVudHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjaGFuZ2VFdmVudEFyZ3MgPSBuZXcgQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJnczxUPihcclxuICAgICAgICAgICAgaW5kZXhNYXAsXHJcbiAgICAgICAgICAgIG5ld0VsZW1lbnRzLFxyXG4gICAgICAgICAgICBjYW5jZWxhYmxlQ2hhbmdlRXZlbnRBcmdzLmdldFByZXZlbnREZWZhdWx0KCksXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KENPTExFQ1RJT05fTUFOQUdFUl9FVkVOVFMuY29sbGVjdGlvbkFmdGVyQ2hhbmdlLCBjaGFuZ2VFdmVudEFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2VFdmVudEFyZ3M7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcclxuaW1wb3J0IHsgQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJncyB9IGZyb20gJy4vY29sbGVjdGlvbi1jaGFuZ2UtYXJncyc7XHJcbmltcG9ydCB7IENvbGxlY3Rpb25NYW5hZ2VyIH0gZnJvbSAnLi9jb2xsZWN0aW9uLW1hbmFnZXInO1xyXG5cclxuZXhwb3J0IGNsYXNzIEh0bWxDaGlsZHJlbk1hbmFnZXIgZXh0ZW5kcyBDb2xsZWN0aW9uTWFuYWdlcjxIVE1MRWxlbWVudD4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJlbnQgZWxlbWVudCBvZiB0aGUgbWVtYmVycyBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGFyZW50RWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb246IEhUTUxFbGVtZW50W10sIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyLCBwYXJlbnRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNvbGxlY3Rpb24sIGV2ZW50RW1pdHRlcik7XHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXBzIHRvIGNoYW5nZSB0aGUgY29sbGVjdGlvbiBtYW5hZ2VkIGJ5IHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhNYXAgTWFwIGZyb20gb2xkIGluZGV4ZXMgdG8gbmV3IGluZGV4ZXMuXHJcbiAgICAgKiBAcGFyYW0gbmV3RWxlbWVudHMgTmV3IGVsZW1lbnRzIHRvIG1hbmFnZSBpZiB0aGUgY2hhbmdlIGlzIG5vdCBwcmV2ZW50ZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbnRlcm5hbFRyeVRvQ2hhbmdlQ29sbGVjdGlvbihcclxuICAgICAgICBpbmRleE1hcDoge1tvbGRJbmRleDogbnVtYmVyXTogbnVtYmVyfSA9IHt9LFxyXG4gICAgICAgIG5ld0VsZW1lbnRzOiBIVE1MRWxlbWVudFtdLFxyXG4gICAgKTogQ29sbGVjdGlvbkNoYW5nZUV2ZW50QXJnczxIVE1MRWxlbWVudD4ge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IHN1cGVyLmludGVybmFsVHJ5VG9DaGFuZ2VDb2xsZWN0aW9uKGluZGV4TWFwLCBuZXdFbGVtZW50cyk7XHJcblxyXG4gICAgICAgIGlmICghZXZlbnRBcmdzLmdldFByZXZlbnREZWZhdWx0KCkpIHtcclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBET00gbW9kaWZpY2F0aW9ucy5cclxuICAgICAgICAgICAgdmFyIGRlbGV0aW9uUGl2b3QgPSAwO1xyXG4gICAgICAgICAgICB2YXIgaW5zZXJ0aW9uUGl2b3QgPSAwO1xyXG4gICAgICAgICAgICB2YXIgb2xkSW5kZXhlc0NvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICB2YXIgbmV3SW5kZXhlc0NvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gSW1wb3J0YW50OiBLZXlzIG11c3QgYmUgZ3VhcmFudGVlZCB0byBiZSBvcmRlcmVkIVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmRleE1hcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlOdW1iZXI6IG51bWJlciA9IE51bWJlcihrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvbGRJbmRleGVzQ291bnRlcjsgaSA8IGtleU51bWJlcjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBvbGQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMucGFyZW50RWxlbWVudC5jaGlsZHJlbltpICsgaW5zZXJ0aW9uUGl2b3QgLSBkZWxldGlvblBpdm90XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrZGVsZXRpb25QaXZvdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4OiBudW1iZXIgPSBpbmRleE1hcFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBuZXdJbmRleGVzQ291bnRlcjsgaSA8IG5ld0luZGV4OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IG5ldyBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50c1tpXSwgdGhpcy5wYXJlbnRFbGVtZW50LmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKytpbnNlcnRpb25QaXZvdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG9sZEluZGV4ZXNDb3VudGVyID0ga2V5TnVtYmVyICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleGVzQ291bnRlciA9IG5ld0luZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG5ld0luZGV4ZXNDb3VudGVyOyBpIDwgbmV3RWxlbWVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChuZXdFbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBldmVudEFyZ3M7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIFRva2VuTWFwPFQ+IHtcclxuICAgIC8vI3JlZ2lvbiBQcm9wZXJ0aWVzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbm5lciBtYXAuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbm5lck1hcDogTWFwPG51bWJlciwgVD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0IG9mIHVudXNlZCBpbmRleGVkIGJlbGxvdyB0aGUgbWF4aW11biB1c2VkIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdW51c2VkSW5kZXhlczogbnVtYmVyW107XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaW5uZXJNYXAgPSBuZXcgTWFwPG51bWJlciwgVD4oKTtcclxuICAgICAgICB0aGlzLnVudXNlZEluZGV4ZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgYXJyYXkgY29sbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBlbGVtIEVsZW1lbnQgdG8gYmUgYWRkZWQgdG8gdGhlIGFycmF5LlxyXG4gICAgICogQHJldHVybnMgaW5kZXggaW4gd2hpY2ggdGhlIGVsZW1lbnQgaXMgbG9jYXRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChlbGVtOiBUKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAoMCA9PT0gdGhpcy51bnVzZWRJbmRleGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXg6IG51bWJlciA9IHRoaXMuaW5uZXJNYXAuc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5pbm5lck1hcC5zZXQobGFzdEluZGV4LCBlbGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3RJbmRleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXg6IG51bWJlciA9IHRoaXMudW51c2VkSW5kZXhlc1t0aGlzLnVudXNlZEluZGV4ZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIC0tdGhpcy51bnVzZWRJbmRleGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5pbm5lck1hcC5zZXQobGFzdEluZGV4LCBlbGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3RJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIHRoZSBhbW91bnQgb2YgZWxlbWVudHMgaW5zaWRlIHRoZSBhcnJheS5cclxuICAgICAqIEByZXR1cm5zIEFtb3VudCBvZiBlbGVtZW50cyBpbnNpZGUgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY291bnQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbm5lck1hcC5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgYXJyYXkgYW5kIGFwcGxpZXMgYSBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSBjb25zdW1lciBGdW5jdGlvbiB0byBhcHBseSB0byBhbnkgcGFpciBvZiBpbmRleC1lbGVtZW50IGZvdW5kICh1bmRlZmluZWQgdmFsdWVzIGFyZSBkaXNjYXJ0ZWQpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZm9yZWFjaChjb25zdW1lcjogKHZhbHVlOiBULCBrZXk6IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaW5uZXJNYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTogVCwga2V5OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3VtZXIodmFsdWUsIGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGFuIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cclxuICAgICAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byBvYnRhaW50LlxyXG4gICAgICogQHJldHVybnMgRWxlbWVudCBvYnRpYW5lZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KGluZGV4OiBudW1iZXIpOiBUIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbm5lck1hcC5nZXQoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGF0IHRoZSBwb3NpdGlvbiBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGhpcy5pbm5lck1hcC5oYXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXJNYXAuZGVsZXRlKGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy51bnVzZWRJbmRleGVzW3RoaXMudW51c2VkSW5kZXhlcy5sZW5ndGhdID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwicmVxdWlyZSgnY29yZS1qcy9mbi9wcm9taXNlJyk7XG5cbmltcG9ydCB7XG4gICAgU0lOR0xFX1NMSURFX0NBUk9VU0VMX0FDVElPTlMsXG4gICAgU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUyxcbiAgICBTSU5HTEVfU0xJREVfQ0FST1VTRUxfU1RZTEVTLFxuICAgIFNpbmdsZVNsaWRlQ2Fyb3VzZWwsXG4gfSBmcm9tICcuL2Nhcm91c2VsL3NpbmdsZS1zbGlkZS9zaW5nbGUtc2xpZGUtY2Fyb3VzZWwnO1xuXG5jb25zdCBzb3JhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgU2luZ2xlU2xpZGVDYXJvdXNlbDogU2luZ2xlU2xpZGVDYXJvdXNlbCxcbiAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgU0lOR0xFX1NMSURFX0NBUk9VU0VMX0FDVElPTlMgOiBTSU5HTEVfU0xJREVfQ0FST1VTRUxfQUNUSU9OUyxcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBTSU5HTEVfU0xJREVfQ0FST1VTRUxfRVZFTlRTIDogU0lOR0xFX1NMSURFX0NBUk9VU0VMX0VWRU5UUyxcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICBTSU5HTEVfU0xJREVfQ0FST1VTRUxfU1RZTEVTIDogU0lOR0xFX1NMSURFX0NBUk9VU0VMX1NUWUxFUyxcbiAgICAgICAgfSxcbiAgICB9O1xufSAoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3JhO1xuIiwiLyoqXHJcbiAqIENvbnN0cmFpbnQgdGhhdCBkZXRlcm1pbmVzIHRoZSBzdGFydCBvZiB0aGUgdGFzayBwYXJ0LlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJVGFza1BhcnRXaGVuQ29uc3RyYWludCB7XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gZW50aXR5IHRvIGNoZWNrIG9uY2UgdGhpcyBjb25zdHJhaW50IGlzIGVuc3VyZWQuXHJcbiAgICAgKi9cclxuICAgIGFmdGVyOiBJVGFza1BhcnRXaGVuQ29uc3RyYWludDtcclxuICAgIC8qKlxyXG4gICAgICogVHlwZSBvZiB0aGlzIGNvbnN0cmFpbnQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cmFpbnRUeXBlOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJhaW50IHRoYXQgZGV0ZXJtaW5lcyB0aGUgc3RhcnQgb2YgdGhlIHRhc2sgcGFydC5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUYXNrUGFydFdoZW5Db25zdHJhaW50IGltcGxlbWVudHMgSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGVudGl0eSB0byBjaGVjayBvbmNlIHRoaXMgY29uc3RyYWludCBpcyBlbnN1cmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWZ0ZXI6IElUYXNrUGFydFdoZW5Db25zdHJhaW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlIG9mIHRoaXMgY29uc3RyYWludC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cmFpbnRUeXBlOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhc2sgcGFydCBjb25zdHJhaW50LlxyXG4gICAgICogQHBhcmFtIGFmdGVyIENvbnN0cmFpbnQgdG8gYXBwbHkgYWZ0ZXIgdGhpcyBjb25zdHJhaW50IGlzIGNoZWNrZWQuXHJcbiAgICAgKiBAcGFyYW0gY29uc3RyYWludFR5cGUgQ29uc3RyYWludCB0eXBlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoYWZ0ZXI6IElUYXNrUGFydFdoZW5Db25zdHJhaW50LCBjb25zdHJhaW50VHlwZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5hZnRlciA9IGFmdGVyO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludFR5cGUgPSBjb25zdHJhaW50VHlwZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgSVRhc2tQYXJ0V2hlbkNvbnN0cmFpbnQsXHJcbiAgICBUYXNrUGFydFdoZW5Db25zdHJhaW50LFxyXG59IGZyb20gJy4vdGFzay1mbG93LXdoZW4nO1xyXG5cclxuLyoqXHJcbiAqIFRhc2sgY29uc3RyYWludCB0eXBlc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRBU0tfQ09OU1RSQUlOVF9UWVBFUyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZXMgdGhlIGVuZCBvZiBhIHRhc2sgcGFydC5cclxuICAgICAqL1xyXG4gICAgRU5EOiAnYW5pbS5lbmQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlcyBhIGdyb3VwIG9mIGNvbnN0cmFpbnRzLlxyXG4gICAgICovXHJcbiAgICBHUk9VUDogJ2dyb3VwJyxcclxuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZXMgdGhlIHN0YXJ0IG9mIGEgdGFzayBwYXJ0LlxyXG4gICAgICovXHJcbiAgICBTVEFSVCA6ICdhbmltLnN0YXJ0JyxcclxuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZXMgYW4gYW1vdW50IG9mIHRpbWUuXHJcbiAgICAgKi9cclxuICAgIFdBSVRfRk9SOiAnd2FpdCcsXHJcbn07XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGFza1BhcnRDb25zdHJhaW50IGV4dGVuZHMgVGFza1BhcnRXaGVuQ29uc3RyYWludCB7XHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIG9mIHRoZSBwYXJ0IGFmZmVjdGVkIGJ5IHRoaXMgY29uc3RyYWludC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFsaWFzOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhc2sgcGFydCBjb25zdHJhaW50LlxyXG4gICAgICogQHBhcmFtIGFmdGVyIENvbnN0cmFpbnQgdG8gYXBwbHkgYWZ0ZXIgdGhpcyBjb25zdHJhaW50IGlzIGNoZWNrZWQuXHJcbiAgICAgKiBAcGFyYW0gYWxpYXMgQWxpYXNlcyBvZiB0aGUgcGFydHMgYWZmZWN0ZWQgYnkgdGhpcyBjb25zdHJhaW50LlxyXG4gICAgICogQHBhcmFtIGNvbnN0cmFpbnRUeXBlIENvbnN0cmFpbnQgdHlwZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGFmdGVyOiBJVGFza1BhcnRXaGVuQ29uc3RyYWludCwgYWxpYXM6IHN0cmluZywgY29uc3RyYWludFR5cGU6IHN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKGFmdGVyLCBjb25zdHJhaW50VHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xyXG5pbXBvcnQgeyBUb2tlbk1hcCB9IGZyb20gJy4uLy4uL2NvbGxlY3Rpb24vdG9rZW4tbWFwJztcclxuaW1wb3J0IHsgSU9wZXJhdGlvbk1hbmFnZXJBY2Nlc3MgfSBmcm9tICcuL29wZXJhdGlvbi1tYW5hZ2VyLWFjY2Vzcyc7XHJcblxyXG4vKipcclxuICogT3BlcmF0aW9uIGFyZ3VtZW50c1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJT3BlcmF0aW9uQXJncyB7XHJcbiAgICBhbGlhc2VzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gb3BlcmF0aW9uIG1hbmFnZXIuIFRoZSBvcGVyYXRpb24gaXMgcHJvcGFnYXRlZCB1c2luZyBhbiBldmVudC5cclxuICogQWxsIHRoZSBzdWJzY3JpYmVyc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE9wZXJhdGlvbk1hbmFnZXI8QXJncyBleHRlbmRzIElPcGVyYXRpb25BcmdzPiBpbXBsZW1lbnRzIElPcGVyYXRpb25NYW5hZ2VyQWNjZXNzPEFyZ3M+IHtcclxuXHJcbiAgICAvLyNyZWdpb24gQXR0cmlidXRlc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIGhhbmRsZSB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjYWxsRnVuY3Rpb246IChldmVudEFyZ3M6IEFyZ3MpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBldmVudEFsaWFzOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBlbW1pdHRlciBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9iamVjdCB0byBzdG9yYWdlIGFsbCB0aGUgZnVuY3Rpb25zIHN1YnNjcmliZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdWJzY3JpcHRpb25TdG9yYWdlOiB7IFthbGlhczogc3RyaW5nXTogVG9rZW5NYXA8KGV2ZW50QXJnczogQXJncykgPT4gdm9pZD4gfTtcclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgb3BlcmF0aW9uIG1hbmFnZXJcclxuICAgICAqIEBwYXJhbSBldmVudEFsaWFzIEV2ZW50IGFsaWFzLlxyXG4gICAgICogQHBhcmFtIGV2ZW50RW1pdHRlciBFdmVudCBlbWl0dGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoZXZlbnRBbGlhczogc3RyaW5nLCBldmVudEVtaXR0ZXI6IEV2ZW50RW1pdHRlcikge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2FsbEZ1bmN0aW9uID0gZnVuY3Rpb24oZXZlbnRBcmdzOiBBcmdzKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGlmIChldmVudEFyZ3MuYWxpYXNlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIGluIHRoYXQuc3Vic2NyaXB0aW9uU3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnN1YnNjcmlwdGlvblN0b3JhZ2UuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhhdC5zdWJzY3JpcHRpb25TdG9yYWdlW2FsaWFzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLmZvcmVhY2goZnVuY3Rpb24odmFsdWU6IChldmVudEFyZ3M6IEFyZ3MpID0+IHZvaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZShldmVudEFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGV2ZW50QXJncy5hbGlhc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGF0LnN1YnNjcmlwdGlvblN0b3JhZ2VbYWxpYXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVycyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLmZvcmVhY2goZnVuY3Rpb24odmFsdWU6IChldmVudEFyZ3M6IEFyZ3MpID0+IHZvaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKGV2ZW50QXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRBbGlhcyA9IGV2ZW50QWxpYXM7XHJcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdG9yYWdlID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmFkZExpc3RlbmVyKHRoaXMuZXZlbnRBbGlhcywgdGhpcy5jYWxsRnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZXMgdGhlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50QWxpYXMsIHRoaXMuY2FsbEZ1bmN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnN0cmliZXMgYSBoYW5kbGVyIHVuZGVyIGFuIGFsaWFzLlxyXG4gICAgICogQHBhcmFtIGFsaWFzIEFsaWFzIG9mIHRoZSBoYW5kbGVyLlxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgSGFuZGxlciB0byBiZSBzdWJzY3JpYmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3Vic2NyaWJlKGFsaWFzOiBzdHJpbmcsIGhhbmRsZXI6IChldmVudEFyZ3M6IEFyZ3MpID0+IHZvaWQpOiBudW1iZXIge1xyXG4gICAgICAgIGlmIChudWxsID09IHRoaXMuc3Vic2NyaXB0aW9uU3RvcmFnZVthbGlhc10pIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdG9yYWdlW2FsaWFzXSA9IG5ldyBUb2tlbk1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25TdG9yYWdlW2FsaWFzXS5hZGQoaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgYSBoYW5kbGVyIHVuZGVyIGFuIGFsaWFzLlxyXG4gICAgICogQHBhcmFtIGFsaWFzIEFsaWFzIG9mIHRoZSBoYW5kbGVyLlxyXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IG9mIHRoZSBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdW5zdWJzY3JpYmUoYWxpYXM6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChudWxsID09IHRoaXMuc3Vic2NyaXB0aW9uU3RvcmFnZVthbGlhc10pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvblN0b3JhZ2VbYWxpYXNdLnJlbW92ZShpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XHJcbmltcG9ydCB7IElUYXNrRmxvdyB9IGZyb20gJy4vZmxvdy90YXNrLWZsb3cnO1xyXG5pbXBvcnQgeyBJVGFza0Zsb3dQYXJ0IH0gZnJvbSAnLi9mbG93L3Rhc2stZmxvdy1wYXJ0JztcclxuaW1wb3J0IHtcclxuICAgIElUYXNrRmxvd1BhcnRFbmRBcmdzLFxyXG4gICAgSVRhc2tGbG93UGFydFN0YXJ0QXJncyxcclxufSBmcm9tICcuL2Zsb3cvdGFzay1mbG93LXBhcnQtZXZlbnQtYXJncyc7XHJcbmltcG9ydCB7IElUYXNrUGFydFdoZW5Db25zdHJhaW50IH0gZnJvbSAnLi9mbG93L3Rhc2stZmxvdy13aGVuJztcclxuaW1wb3J0IHsgVGFza1BhcnRCZWdpbkNvbnN0cmFpbnQgfSBmcm9tICcuL2Zsb3cvdGFzay1wYXJ0LWJlZ2luLWNvbnN0cmFpbnQnO1xyXG5pbXBvcnQgeyBUQVNLX0NPTlNUUkFJTlRfVFlQRVMgfSBmcm9tICcuL2Zsb3cvdGFzay1wYXJ0LWNvbnN0cmFpbnQnO1xyXG5pbXBvcnQgeyBUYXNrUGFydEVuZENvbnN0cmFpbnQgfSBmcm9tICcuL2Zsb3cvdGFzay1wYXJ0LWVuZC1jb25zdHJhaW50JztcclxuaW1wb3J0IHsgVGFza0dyb3VwQ29uc3RyYWludCB9IGZyb20gJy4vZmxvdy90YXNrLXBhcnQtZ3JvdXAtY29uc3RyYWludCc7XHJcbmltcG9ydCB7IFRhc2tUaW1lQ29uc3RyYWludCB9IGZyb20gJy4vZmxvdy90YXNrLXBhcnQtdGltZS1jb25zdHJhaW50JztcclxuaW1wb3J0IHsgT3BlcmF0aW9uTWFuYWdlciB9IGZyb20gJy4vb3BlcmF0aW9uL29wZXJhdGlvbi1tYW5hZ2VyJztcclxuaW1wb3J0IHsgSU9wZXJhdGlvbk1hbmFnZXJBY2Nlc3MgfSBmcm9tICcuL29wZXJhdGlvbi9vcGVyYXRpb24tbWFuYWdlci1hY2Nlc3MnO1xyXG5pbXBvcnQgeyBUQVNLX1BBUlRfV0hFTl9FVkVOVFMgfSBmcm9tICcuL3Rhc2stcGFydC13aGVuLWV2ZW50cyc7XHJcbmltcG9ydCB7IFRhc2tQYXJ0V2hlbk9wZXJhdG9yIH0gZnJvbSAnLi90YXNrLXBhcnQtd2hlbi1vcGVyYXRvcic7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHRhc2sgZW5naW5lLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRhc2tFbmdpbmU8VFBhcnQgZXh0ZW5kcyBJVGFza0Zsb3dQYXJ0PiB7XHJcbiAgICAvLyNyZWdpb24gQXR0cmlidXRlc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFzayBjdXJyZW50bHkgbWFuYWdlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRUYXNrOiBJVGFza0Zsb3c8VFBhcnQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgZW1pdHRlciB0byB1c2VcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyO1xyXG5cclxuICAgIC8vI3JlZ2lvbiBPcGVyYXRpb25zXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VyIHRoYXQgaGFuZGxlcyB0aGUgcGFydCBlbmQgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwYXJ0RW5kTWFuYWdlcjogT3BlcmF0aW9uTWFuYWdlcjxJVGFza0Zsb3dQYXJ0RW5kQXJnczxUUGFydD4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFuYWdlciB0aGF0IGhhbmRsZXMgdGhlIHBhcnQgc3RhcnQgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwYXJ0U3RhcnRNYW5hZ2VyOiBPcGVyYXRpb25NYW5hZ2VyPElUYXNrRmxvd1BhcnRTdGFydEFyZ3M8VFBhcnQ+PjtcclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUHVibGljXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMucGFydEVuZE1hbmFnZXIgPSBuZXcgT3BlcmF0aW9uTWFuYWdlcjxJVGFza0Zsb3dQYXJ0RW5kQXJnczxUUGFydD4+KFxyXG4gICAgICAgICAgICBUQVNLX1BBUlRfV0hFTl9FVkVOVFMuRU5ELFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlcixcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMucGFydFN0YXJ0TWFuYWdlciA9IG5ldyBPcGVyYXRpb25NYW5hZ2VyPElUYXNrRmxvd1BhcnRTdGFydEFyZ3M8VFBhcnQ+PihcclxuICAgICAgICAgICAgVEFTS19QQVJUX1dIRU5fRVZFTlRTLlNUQVJULFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlcixcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgYWNjZXNzIG9mIHRoZSBwYXJ0IGVuZCBldmVudC5cclxuICAgICAqIEByZXR1cm5zIEFjY2VzcyBvZiB0aGUgcGFydCBlbmQgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQYXJ0RW5kTGlzdGVuZXJBY2Nlc3MoKTogSU9wZXJhdGlvbk1hbmFnZXJBY2Nlc3M8SVRhc2tGbG93UGFydEVuZEFyZ3M8VFBhcnQ+PiB7XHJcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbihcclxuICAgICAgICAgICAgICAgIGFsaWFzOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiAoZXZlbnRBcmdzOiBJVGFza0Zsb3dQYXJ0RW5kQXJnczxUUGFydD4pID0+IHZvaWQsXHJcbiAgICAgICAgICAgICk6IG51bWJlciB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5wYXJ0RW5kTWFuYWdlci5zdWJzY3JpYmUoYWxpYXMsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oYWxpYXM6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQucGFydEVuZE1hbmFnZXIudW5zdWJzY3JpYmUoYWxpYXMsIGluZGV4KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgYWNjZXNzIG9mIHRoZSBwYXJ0IHN0YXJ0IGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgQWNjZXNzIG9mIHRoZSBwYXJ0IHN0YXJ0IGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGFydFN0YXJ0TGlzdGVuZXJBY2Nlc3MoKTogSU9wZXJhdGlvbk1hbmFnZXJBY2Nlc3M8SVRhc2tGbG93UGFydFN0YXJ0QXJnczxUUGFydD4+IHtcclxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uKFxyXG4gICAgICAgICAgICAgICAgYWxpYXM6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IChldmVudEFyZ3M6IElUYXNrRmxvd1BhcnRTdGFydEFyZ3M8VFBhcnQ+KSA9PiB2b2lkLFxyXG4gICAgICAgICAgICApOiBudW1iZXIge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQucGFydFN0YXJ0TWFuYWdlci5zdWJzY3JpYmUoYWxpYXMsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oYWxpYXM6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQucGFydFN0YXJ0TWFuYWdlci51bnN1YnNjcmliZShhbGlhcywgaW5kZXgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGEgdGFzayBmbG93LlxyXG4gICAgICogQHBhcmFtIHRhc2tGbG93IFRhc2sgZmxvdyB0byBiZSBtYW5hZ2VkLlxyXG4gICAgICogQHJldHVybnMgVGFzayBwYXJ0IHByb21pc2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGFuZGxlKHRhc2tGbG93OiBJVGFza0Zsb3c8VFBhcnQ+KTogQXJyYXk8UHJvbWlzZTx2b2lkPj4ge1xyXG4gICAgICAgIGlmICh0YXNrRmxvdyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSXRcXCdzIHJlcXVpcmVkIGEgdGFzayBmbG93LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFza0Zsb3cucGFydHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0XFwncyByZXF1aXJlZCBhIHRhc2sgZmxvdyB3aXRoIHBhcnRzLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGFzayA9IHRhc2tGbG93O1xyXG4gICAgICAgIGNvbnN0IHBhcnRQcm9taXNlczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSBuZXcgQXJyYXkodGFza0Zsb3cucGFydHMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXNrRmxvdy5wYXJ0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBwYXJ0UHJvbWlzZXNbaV0gPSB0aGlzLmhhbmRsZVRhc2tQYXJ0KHRhc2tGbG93LnBhcnRzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJ0UHJvbWlzZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGEgdGFzayBwYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJ0IFRhc2sgcGFydCB0byBoYW5kbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSBwYXJ0IG9mIHRoZSB0YXNrIGlzIGZpbmlzaGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaGFuZGxlVGFza1BhcnQocGFydDogVFBhcnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0aGF0LmhhbmRsZVRhc2tQYXJ0V2hlbihwYXJ0LndoZW4pLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBFbWl0IHRoZSBzdGFydCBvZiB0YXNrIHBhcnQuXHJcbiAgICAgICAgICAgICAgICB0aGF0LmV2ZW50RW1pdHRlci5lbWl0KFxyXG4gICAgICAgICAgICAgICAgICAgIFRBU0tfUEFSVF9XSEVOX0VWRU5UUy5TVEFSVCxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzZXM6IFtwYXJ0LmFsaWFzXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydDogcGFydCxcclxuICAgICAgICAgICAgICAgICAgICB9IGFzIElUYXNrRmxvd1BhcnRTdGFydEFyZ3M8VFBhcnQ+LFxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlOiBQcm9taXNlTGlrZTx7fSB8IHZvaWQ+ID0gdGhhdC5wZXJmb3JtVGFzayhwYXJ0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMy4gRW1pdCB0aGUgZW5kIG9mIHRoZSB0YXNrIHBhcnQgYW5kIHJlc29sdmUgdGhlIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ldmVudEVtaXR0ZXIuZW1pdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgVEFTS19QQVJUX1dIRU5fRVZFTlRTLkVORCxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXNlczogW3BhcnQuYWxpYXNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydDogcGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBJVGFza0Zsb3dQYXJ0RW5kQXJnczxUUGFydD4sXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgdGFzayBwYXJ0LlxyXG4gICAgICogQHBhcmFtIHBhcnQgVGFzayBwYXJ0IHRvIGJlIHBlcmZvcm1lZC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2ZWQgb25jZSB0aGUgcGFydCB0YXNrIGlzIHBlcmZvcm1lZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHBlcmZvcm1UYXNrKHBhcnQ6IFRQYXJ0KTogUHJvbWlzZUxpa2U8e30gfCB2b2lkPjtcclxuXHJcbiAgICAvLyNyZWdpb24gVGFza1BhcnRXaGVuY29uc3RyYWludFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB0aGUgd2hlbiBlbnRpdHkgb2YgYSB0YXNrIHBhcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdoZW5FbnRpdHkgV2hlbiBlbnRpdHkgdG8gaGFuZGxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2ZWQgb25jZSB0aGUgd2hlbiBlbnRpdHkgaXMgY2hlY2tlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZVRhc2tQYXJ0V2hlbih3aGVuRW50aXR5OiBJVGFza1BhcnRXaGVuQ29uc3RyYWludCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gd2hlbkVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh3aGVuRW50aXR5LmNvbnN0cmFpbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUQVNLX0NPTlNUUkFJTlRfVFlQRVMuU1RBUlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlVGFza1BhcnRXaGVuUGFydEJlZ2lucyh3aGVuRW50aXR5IGFzIFRhc2tQYXJ0QmVnaW5Db25zdHJhaW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEFTS19DT05TVFJBSU5UX1RZUEVTLkVORDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVUYXNrUGFydFdoZW5QYXJ0RW5kcyh3aGVuRW50aXR5IGFzIFRhc2tQYXJ0RW5kQ29uc3RyYWludClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFRBU0tfQ09OU1RSQUlOVF9UWVBFUy5HUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVUYXNrUGFydFdoZW5QYXJ0R3JvdXAod2hlbkVudGl0eSBhcyBUYXNrR3JvdXBDb25zdHJhaW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVEFTS19DT05TVFJBSU5UX1RZUEVTLldBSVRfRk9SOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVRhc2tQYXJ0V2hlbldhaXRGb3Iod2hlbkVudGl0eSBhcyBUYXNrVGltZUNvbnN0cmFpbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHdoZW4gZW50aXR5IHR5cGUuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgdGhlIHdoZW4gZW50aXR5IChUYXNrUGFydEJlZ2luQ29uc3RyYWludCkgb2YgYSB0YXNrIHBhcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdoZW5FbnRpdHkgV2hlbiBlbnRpdHkgdG8gaGFuZGxlLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCBvbmNlIHRoZSB3aGVuIGVudGl0eSBpcyBjaGVja2VkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaGFuZGxlVGFza1BhcnRXaGVuUGFydEJlZ2lucyh3aGVuRW50aXR5OiBUYXNrUGFydEJlZ2luQ29uc3RyYWludCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnBhcnRTdGFydE1hbmFnZXIudW5zdWJzY3JpYmUod2hlbkVudGl0eS5hbGlhcywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gd2hlbkVudGl0eS5hZnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVUYXNrUGFydFdoZW4od2hlbkVudGl0eS5hZnRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuOiBudW1iZXIgPSB0aGF0LnBhcnRTdGFydE1hbmFnZXIuc3Vic2NyaWJlKHdoZW5FbnRpdHkuYWxpYXMsIGV2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSB3aGVuIGVudGl0eSAoVGFza1BhcnRFbmRDb25zdHJhaW50KSBvZiBhIHRhc2sgcGFydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2hlbkVudGl0eSBXaGVuIGVudGl0eSB0byBoYW5kbGUuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmVkIG9uY2UgdGhlIHdoZW4gZW50aXR5IGlzIGNoZWNrZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBoYW5kbGVUYXNrUGFydFdoZW5QYXJ0RW5kcyh3aGVuRW50aXR5OiBUYXNrUGFydEVuZENvbnN0cmFpbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJ0RW5kTWFuYWdlci51bnN1YnNjcmliZSh3aGVuRW50aXR5LmFsaWFzLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSB3aGVuRW50aXR5LmFmdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVRhc2tQYXJ0V2hlbih3aGVuRW50aXR5LmFmdGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW46IG51bWJlciA9IHRoYXQucGFydEVuZE1hbmFnZXIuc3Vic2NyaWJlKHdoZW5FbnRpdHkuYWxpYXMsIGV2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSB3aGVuIGVudGl0eSAoVGFza0dyb3VwQ29uc3RyYWludCkgb2YgYSB0YXNrIHBhcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdoZW5FbnRpdHkgV2hlbiBlbnRpdHkgdG8gaGFuZGxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2ZWQgb25jZSB0aGUgd2hlbiBlbnRpdHkgaXMgY2hlY2tlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhhbmRsZVRhc2tQYXJ0V2hlblBhcnRHcm91cCh3aGVuRW50aXR5OiBUYXNrR3JvdXBDb25zdHJhaW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFByb21pc2VzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IG5ldyBBcnJheSh3aGVuRW50aXR5LmNvbnN0cmFpbnRzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdoZW5FbnRpdHkuY29uc3RyYWludHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkUHJvbWlzZXNbaV0gPSBuZXcgUHJvbWlzZTx2b2lkPihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZVRhc2tQYXJ0V2hlbih3aGVuRW50aXR5LmNvbnN0cmFpbnRzW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoVGFza1BhcnRXaGVuT3BlcmF0b3IuQU5EID09PSB3aGVuRW50aXR5Lm9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChjaGlsZFByb21pc2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVGFza1BhcnRXaGVuT3BlcmF0b3IuT1IgPT09IHdoZW5FbnRpdHkub3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIFByb21pc2UucmFjZShjaGlsZFByb21pc2VzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoJ1VuZXhwZWN0ZWQgb3BlcmF0b3IuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgdGhlIHdoZW4gZW50aXR5IChUYXNrVGltZUNvbnN0cmFpbnQpIG9mIGEgdGFzayBwYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aGVuRW50aXR5IFdoZW4gZW50aXR5IHRvIGhhbmRsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmVkIG9uY2UgdGhlIHdoZW4gZW50aXR5IGlzIGNoZWNrZWQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBoYW5kbGVUYXNrUGFydFdoZW5XYWl0Rm9yKHdoZW5FbnRpdHk6IFRhc2tUaW1lQ29uc3RyYWludCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3aGVuRW50aXR5LmFmdGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlVGFza1BhcnRXaGVuKHdoZW5FbnRpdHkuYWZ0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB3aGVuRW50aXR5Lm1pbGxpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbn1cclxuIiwiLyoqXHJcbiAqIFByZWZpeGVzIHVzZWQgdG8gZ2FuZXJhdGUgYWxpYXMgZm9yIGV2ZW50cyBvdmVyIHRhc2sgcGFydHMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVEFTS19QQVJUX1dIRU5fRVZFTlRTID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVmaXggZm9yIGFueSBldmVudCByYWlzZWQgb25jZSBhIHRhc2sgcGFydCBpcyBlbmRlZC5cclxuICAgICAqL1xyXG4gICAgRU5EOiAncGFydC5lbmQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVmaXggZm9yIGFueSBldmVudCByYWlzZWQgb25jZSBhIHRhc2sgcGFydCBpcyBzdGFydGVkLlxyXG4gICAgICovXHJcbiAgICBTVEFSVDogJ3BhcnQuc3RhcnQnLFxyXG59O1xyXG4iLCIvKipcclxuICogTG9naWNhbCBvcGVyYXRvciB0byBhcHBseS5cclxuICovXHJcbmV4cG9ydCBlbnVtIFRhc2tQYXJ0V2hlbk9wZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQW5kIG9wZXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBBTkQsXHJcbiAgICAvKipcclxuICAgICAqIE9yIG9wZXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBPUixcclxufVxyXG4iLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZlwiKTtcblxudmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlXCIpO1xuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldDsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBkZWZhdWx0OiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7IiwiZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YyKG9iaik7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihTeW1ib2wuaXRlcmF0b3IpID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMCcgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpXG4gICAgICAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2VcbiAgICAgIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgICAgLy8gd2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwXG4gICAgICAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY2JykgPT09IC0xO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcbiIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIl19"}